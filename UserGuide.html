

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>User Guide &mdash; PySys v1.6.1  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Project Configuration" href="ProjectConfig.html" />
    <link rel="prev" title="The BaseTest Class" href="BaseTest.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> PySys v1.6.1
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BaseTest.html">The BaseTest Class</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#platform-detection">Platform detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#skipping-tests">Skipping tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="#checking-for-error-messages-in-log-files">Checking for error messages in log files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sharing-logic-across-tests-using-plugins">Sharing logic across tests using plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="#configuring-and-overriding-test-options">Configuring and overriding test options</a></li>
<li class="toctree-l2"><a class="reference internal" href="#producing-code-coverage-reports">Producing code coverage reports</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-tests-in-multiple-modes">Running tests in multiple modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#test-ids-and-structuring-large-projects">Test ids and structuring large projects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-execution-order">Controlling execution order</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ProjectConfig.html">Project Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="autodocgen/pysys.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="ChangeLog.html">Change Log</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PySys v1.6.1</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>User Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/UserGuide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="user-guide">
<h1>User Guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="platform-detection">
<h2>Platform detection<a class="headerlink" href="#platform-detection" title="Permalink to this headline">¶</a></h2>
<p>It’s very common to have one set of logic for Windows and another for
all non-Windows (Unix-based) platforms, and PySys has a dedicated constant <a class="reference internal" href="autodocgen/pysys.constants.html#pysys.constants.IS_WINDOWS" title="pysys.constants.IS_WINDOWS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.constants.IS_WINDOWS</span></code></a> for
that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">startProcess</span><span class="p">(</span><span class="s1">&#39;cmd.exe&#39;</span> <span class="k">if</span> <span class="n">IS_WINDOWS</span> <span class="k">else</span> <span class="s1">&#39;bash&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>For finer grained platform detection we recommend using the facilities built into Python, for example
<code class="docutils literal notranslate"><span class="pre">sys.platform</span></code>, <code class="docutils literal notranslate"><span class="pre">platform.platform()</span></code> or <code class="docutils literal notranslate"><span class="pre">platform.uname()</span></code>.</p>
</div>
<div class="section" id="skipping-tests">
<h2>Skipping tests<a class="headerlink" href="#skipping-tests" title="Permalink to this headline">¶</a></h2>
<p>If your <code class="docutils literal notranslate"><span class="pre">run.py</span></code> logic detects that a test should not be executed for this
platform or mode, simply use <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.skipTest" title="pysys.basetest.BaseTest.skipTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">self.skipTest(...)</span></code></a> near the top of the test’s
<a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.execute" title="pysys.basetest.BaseTest.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute()</span></code></a> method, specifying the reason for the skip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s1">&#39;MyFeature is not supported on Windows&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As well as setting the test outcome and reason, this will raise an exception
ensuring that the rest of <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.execute" title="pysys.basetest.BaseTest.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute()</span></code></a> and
<a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.validate" title="pysys.basetest.BaseTest.validate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">validate()</span></code></a> do not get executed.</p>
<p>Alternatively if the test should be skipped regardless of platform/mode etc,
it is best to specify that statically in your <code class="xref py py-obj docutils literal notranslate"><span class="pre">pysystest.xml</span></code> file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">skipped</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;Skipped until bug #12345 is fixed&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="checking-for-error-messages-in-log-files">
<h2>Checking for error messages in log files<a class="headerlink" href="#checking-for-error-messages-in-log-files" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.assertGrep" title="pysys.basetest.BaseTest.assertGrep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.assertGrep()</span></code></a> method is an easy way to check that there are no error
messages in log files from processes started by PySys. Rather than checking for
an expression such as <code class="xref py py-obj docutils literal notranslate"><span class="pre">'</span> <span class="pre">ERROR:</span> <span class="pre">'</span></code>, it is recommended to define your expression
so that the error message itself is included, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertGrep</span><span class="p">(</span><span class="s1">&#39;myprocess.log&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="s1">&#39; ERROR: .*&#39;</span><span class="p">,</span> <span class="n">contains</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>This approach ensures that the error message itself is included in the test’s
console output, run.log and the summary of failed test outcomes, which avoids
the need to open up the individual logs to find out what happened, and makes it
much easier to triage test failures, especially if several tests fail for the
same reason.</p>
</div>
<div class="section" id="sharing-logic-across-tests-using-plugins">
<h2>Sharing logic across tests using plugins<a class="headerlink" href="#sharing-logic-across-tests-using-plugins" title="Permalink to this headline">¶</a></h2>
<p>Often you will have some standard logic that needs to be used in the execute or validation
of many/all testcases, such as starting the application you’re testing, or checking log files for errors.</p>
<p>The recommended way to do that in PySys is to create one or more “plugins”. There are currently several kinds of plugin:</p>
<ul>
<li><p><strong>test plugins</strong>; instances of test plugins are created for each <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> that is instantiated, which allows them
to operate independently of other tests, starting and stopping processes just like code in the <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> class
would. Test plugins are configured with <code class="docutils literal notranslate"><span class="pre">&lt;test-plugin</span> <span class="pre">classname=&quot;...&quot;</span> <span class="pre">alias=&quot;...&quot;/&gt;</span></code> and can be any Python
class provided it has a method <code class="docutils literal notranslate"><span class="pre">setup(self,</span> <span class="pre">testobj)</span></code> (and no constructor arguments).
As the plugins are instantiated just after the <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> subclass, you can use them any time after (but not within)
your test’s <code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__()</span></code> constructor (for example, in <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.setup" title="pysys.basetest.BaseTest.setup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.setup()</span></code></a>).</p></li>
<li><p><strong>runner plugins</strong>; these are instantiated just once per invocation of PySys, by the BaseRunner,
before <a class="reference internal" href="autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner.setup" title="pysys.baserunner.BaseRunner.setup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.baserunner.BaseRunner.setup()</span></code></a> is called. Unlike test plugins, any processes or state they maintain are
shared across all tests. These can be used to start servers/VMs that are shared across tests.
Runner plugins are configured with <code class="docutils literal notranslate"><span class="pre">&lt;runner-plugin</span> <span class="pre">classname=&quot;...&quot;</span> <span class="pre">alias=&quot;...&quot;/&gt;</span></code> and can be any Python
class provided it has a method <code class="docutils literal notranslate"><span class="pre">setup(self,</span> <span class="pre">runner)</span></code> (and no constructor arguments).</p>
<p>Runner plugins that generate output files/directories should by default put that output under either the
<a class="reference internal" href="autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner" title="pysys.baserunner.BaseRunner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runner.output</span></code></a> directory, or (for increased prominence) the <code class="docutils literal notranslate"><span class="pre">runner.output+'/..'</span></code>
directory (which is typically <code class="docutils literal notranslate"><span class="pre">testRootDir</span></code> unless an absolute <code class="docutils literal notranslate"><span class="pre">--outdir</span></code> path was provided).</p>
</li>
<li><p><strong>writer plugins</strong>: this kind of plugin has existed in PySys for many releases and are effectively a special kind of
runner plugin with extra callbacks to allow them to write test results and/or output files to a variety of
destinations. Writers must implement a similar but different interface to other runner plugins; see <a class="reference internal" href="autodocgen/pysys.writer.html#module-pysys.writer" title="pysys.writer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer</span></code></a>
for details. They can be used for everything from writing test outcome to an XML file, to archiving output files, to
collecting files from each test output and using them to generate a code coverage report during cleanup at the end
of the run.</p></li>
</ul>
<p>To make your plugin configurable, add a static field for each plugin property, which defines the default value
and (implicitly) the type. After construction of each plugin, an attribute is assigned with the actual value
of each plugin property so each property can be accessed using <code class="docutils literal notranslate"><span class="pre">self.propname</span></code> (by the time the plugin’s setup method
is called). In addition to plugin properties, <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span> <span class="pre">-Xkey=value</span></code> command line options for the plugin
(if needed) can be accessed using the runner’s <a class="reference internal" href="autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner.getXArg" title="pysys.baserunner.BaseRunner.getXArg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.baserunner.BaseRunner.getXArg()</span></code></a> method.</p>
<p>A test plugin could look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestPlugin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">myPluginProperty</span> <span class="o">=</span> <span class="s1">&#39;default value&#39;</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Example of a plugin configuration property. The value for this plugin instance can be overridden using ``&lt;property .../&gt;``.</span>
<span class="sd">        Types such as boolean/list[str]/int/float will be automatically converted from string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testObj</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">testObj</span> <span class="o">=</span> <span class="n">testObj</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pysys.myorg.MyRunnerPlugin&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Created MyTestPlugin instance with myPluginProperty=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">myPluginProperty</span><span class="p">)</span>

                <span class="c1"># there is no standard cleanup() method, so do this if you need to execute something on cleanup:</span>
                <span class="n">testObj</span><span class="o">.</span><span class="n">addCleanupFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__myPluginCleanup</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__myPluginCleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Cleaning up MyTestPlugin instance&#39;</span><span class="p">)</span>

        <span class="c1"># An example of providing a method that can be accessed from each test</span>
        <span class="k">def</span> <span class="nf">getPythonVersion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">startProcess</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;--version&#39;</span><span class="p">],</span> <span class="n">stdouterr</span><span class="o">=</span><span class="s1">&#39;MyTestPlugin.pythonVersion&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">waitForGrep</span><span class="p">(</span><span class="s1">&#39;MyTestPlugin.pythonVersion.out&#39;</span><span class="p">,</span> <span class="s1">&#39;(?P&lt;output&gt;.+)&#39;</span><span class="p">)[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c1"># A common pattern is to create a helper method that you always call from your `BaseTest.validate()`</span>
        <span class="c1"># That approach allows you to later customize the logic by changing just one single place, and also to omit</span>
        <span class="c1"># it for specific tests where it is not wanted.</span>
        <span class="k">def</span> <span class="nf">checkLogsForErrors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertGrep</span><span class="p">(</span><span class="s1">&#39;myapp.log&#39;</span><span class="p">,</span> <span class="s1">&#39; ERROR .*&#39;</span><span class="p">,</span> <span class="n">contains</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>With configuration like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">pysysproject</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">test</span><span class="o">-</span><span class="n">plugin</span> <span class="n">classname</span><span class="o">=</span><span class="s2">&quot;myorg.testplugin.MyTestPlugin&quot;</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&quot;myalias&quot;</span><span class="o">&gt;</span>
                    <span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myPluginProperty&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;my value&quot;</span><span class="o">/&gt;</span>
        <span class="o">&lt;/</span><span class="n">test</span><span class="o">-</span><span class="n">plugin</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">pysysproject</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>… you can now access methods defined by the plugin from your tests using <code class="docutils literal notranslate"><span class="pre">self.myalias.getPythonVersion()</span></code>.</p>
<p>Alternatively, you can create a trivial <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> subclass that instantiates plugins in code (rather than XML)
which would allow code completion (if your editor of choice supports this) but still provide the benefits of
the modular composition approach.</p>
<p>You can add any number of test and/or runner plugins to your project, perhaps a mixture of custom plugins specific
to your application, and third party PySys plugins supporting standard tools and languages.</p>
<p>In addition to the alias-based lookup, plugins can get a list of the other plugin instances
using <code class="docutils literal notranslate"><span class="pre">self.testPlugins</span></code> (from <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a>) or <code class="docutils literal notranslate"><span class="pre">self.runnerPlugins</span></code> (from <a class="reference internal" href="autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner" title="pysys.baserunner.BaseRunner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.baserunner.BaseRunner</span></code></a>), which
provides a way for plugins to reference each other without depending on the aliases that may be in use in a
particular project configuration.</p>
<p>When creating a runner plugin you may need somewhere to put output files, logs etc. Plugins that generate output
files/directories should by default put that output in a dedicated directory either the
<a class="reference internal" href="autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner" title="pysys.baserunner.BaseRunner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runner.output</span></code></a> directory, or (for increased prominence if it’s something users will
look at a lot) a directory one level up e.g. <code class="docutils literal notranslate"><span class="pre">runner.output+'/../myplugin'</span></code> (which is typically under <code class="docutils literal notranslate"><span class="pre">testRootDir</span></code>
unless an absolute <code class="docutils literal notranslate"><span class="pre">--outdir</span></code> path was provided) .
A prefix of double underscore <code class="docutils literal notranslate"><span class="pre">__pysys</span></code> is recommended under testRootDir to distinguish dynamically created
directories (ignored by version control) from the testcase directories (checked into version control).</p>
<p>For examples of the project configuration, including how to set plugin-specific properties that will be passed to
its constructor, see the sample Project Configuration file.</p>
</div>
<div class="section" id="configuring-and-overriding-test-options">
<h2>Configuring and overriding test options<a class="headerlink" href="#configuring-and-overriding-test-options" title="Permalink to this headline">¶</a></h2>
<p>PySys provides two mechanisms for specifying options such as credentials,
hostnames, or test duration/iteration that you might want to change or
override when running tests:</p>
<ul>
<li><p><em>Testcase attributes</em>, which are just variables on the Python testcase
instance (or a <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> subclass shared by many tests).
Attributes can be overridden on the command line using <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span> <span class="pre">-Xattr=value</span></code>.</p>
<p>Attributes are useful for settings specific to an individual testcase such as
the number of iterations or time duration to use for a performance test.
A user running the test locally you might want to temporarily set to a lower
iteration count while getting the test right, or perhaps try
a higher value to get a more stable performance result.</p>
</li>
<li><p><em>Project properties</em>. The default value is specified in the <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code>
file or in a <code class="docutils literal notranslate"><span class="pre">.properties</span></code> file referenced from it.</p>
<p>Properties can be overridden using an environment variable.
Project properties are useful for things like credentials and hostnames that
are shared across many testcases, and where you might want to set up
customizations in your shell so that you don’t need to keep specifying them
every time you invoke <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span></code>.</p>
</li>
</ul>
<p>To use a testcase attribute, set the default value on your test or basetest as a static attribute on the test
class, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PySysTest</span><span class="p">(</span><span class="n">BaseTest</span><span class="p">):</span>

        <span class="n">myIterationCount</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="mi">1000</span> <span class="c1"># can be overridden with -XmyIterationCount=</span>

        <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using iterations=</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">myIterationCount</span><span class="p">)</span>
                <span class="o">...</span>
</pre></div>
</div>
<p>Once the default value is defined with a static attribute, you can override the value
when you run your test using the <code class="docutils literal notranslate"><span class="pre">-X</span></code> option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pysys</span> <span class="n">run</span> <span class="o">-</span><span class="n">XmyIterationCount</span><span class="o">=</span><span class="mi">10</span>
</pre></div>
</div>
<p>If the attribute was defined with a default value of int, float, bool or list then
the <code class="docutils literal notranslate"><span class="pre">-X</span></code> value will be automatically converted to that type; otherwise, it will
be a string.</p>
<p>If instead of setting a default for just one test you wish to set the default
for many tests from your custom <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> subclass, then you would do the same thing in the
definition of that <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> subclass. If you don’t have a custom BaseTest class, you can use
<a class="reference internal" href="autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner.getXArg" title="pysys.baserunner.BaseRunner.getXArg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">self.runner.getXArg()</span></code></a> from any plugin to get the value or default, with the same
type conversion described above.</p>
<p>The other mechanism that PySys supports for configurable test options is
project properties.</p>
<p>To use a project property that can be overridden with an environment variable,
add a <code class="docutils literal notranslate"><span class="pre">property</span></code> element to your <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code> file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myCredentials&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{env.MYCOMPANY_CREDENTIALS}</span><span class="s2">&quot;</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;testuser:testpassword&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>This property can will take the value of the specified environment variable,
or else the default if any undefined properties/env vars are included in value. Note that if the value contains
unresolved variables and there is no valid default, the project will fail to load.</p>
<p>You may want to set the attribute <code class="docutils literal notranslate"><span class="pre">pathMustExist=&quot;true&quot;</span></code> when defining properties that refer to a path such as a
build output directory that should always be present.</p>
<p>Another way to specify default project property values is to put them into a
Java-style <code class="docutils literal notranslate"><span class="pre">.properties</span></code> file. You can use properties to specify which file is
loaded, so it would be possible to customize using environment variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myProjectPropertiesFile&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{env.MYCOMPANY_CUSTOM_PROJECT_PROPERTIES}</span><span class="s2">&quot;</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{testRootDir}</span><span class="s2">/default-config.properties&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nb">property</span> <span class="n">file</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{myProjectPropertiesFile}</span><span class="s2">&quot;</span> <span class="n">pathMustExist</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>To use projects properties in your testcase, just access the attributes on
<a class="reference internal" href="autodocgen/pysys.xml.project.html#pysys.xml.project.Project" title="pysys.xml.project.Project"><code class="xref py py-obj docutils literal notranslate"><span class="pre">self.project</span></code></a> from either a test instance or a runner:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using username=</span><span class="si">%s</span><span class="s1"> and password </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">myCredentials</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Property properties will always be of string type.</p>
</div>
<div class="section" id="producing-code-coverage-reports">
<h2>Producing code coverage reports<a class="headerlink" href="#producing-code-coverage-reports" title="Permalink to this headline">¶</a></h2>
<p>PySys can be extended to produce code coverage reports for any language, by creating a writer plugin.</p>
<p>There is an existing writer that produces coverage reports for programs written in Python called
<a class="reference internal" href="autodocgen/pysys.writer.testoutput.html#pysys.writer.testoutput.PythonCoverageWriter" title="pysys.writer.testoutput.PythonCoverageWriter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.testoutput.PythonCoverageWriter</span></code></a>, which uses the <code class="docutils literal notranslate"><span class="pre">coverage.py</span></code> library. To use this you need to add the
<code class="docutils literal notranslate"><span class="pre">&lt;writer&gt;</span></code> to your project (see the sample <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code> for an example) and make sure you’re starting
your Python processes with coverage support enabled, by using <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.startPython" title="pysys.basetest.BaseTest.startPython"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.startPython</span></code></a>.</p>
<p>The usual way to enable code coverage (for all supported languages) is to set <code class="docutils literal notranslate"><span class="pre">-XcodeCoverage</span></code> when running your
tests (or to run with <code class="docutils literal notranslate"><span class="pre">--ci</span></code> which does this automatically). Individual writers may additionally provide their own
properties to allow fine-grained control e.g. <code class="docutils literal notranslate"><span class="pre">-XpythonCoverage=true/false</span></code>.</p>
<p>Be sure to add the <code class="docutils literal notranslate"><span class="pre">disableCoverage</span></code> group to any tests (or test directories) that should not use coverage,
such as performance tests.</p>
<p>If you wish to produce coverage reports using any other language, this is easy to achieve by following the same pattern:</p>
<ul>
<li><p>When your tests start the program(s) whose coverage is to be measured, add the required arguments or environment
variables to enable coverage using the coverage tool of your choice. The most convenient place to put helper methods
for starting your application is in a custom test plugin class.</p>
<p>When starting your process, you can detect whether to enable code coverage like this:</p>
<blockquote>
<div><dl class="simple">
<dt>if self.runner.getBoolProperty(‘mylanguageCoverage’, default=self.runner.getBoolProperty(‘codeCoverage’)) and not self.disableCoverage:</dt><dd><p>…</p>
</dd>
</dl>
</div></blockquote>
<p>Often you will need to set an environment variable to indicate the filename that coverage should be generated under.
Make sure to use a unique filename so that multiple processes started by the same test do not clash. Often you
will need to ensure that your application is shutdown cleanly (rather than being automatically killed at the end of
the test) so that it has a chance to write the code coverage information.</p>
</li>
<li><p>Create a custom writer class which collects coverage files (matching a specific regex pattern) from the output
directory. The usual way to do this would be to subclass <a class="reference internal" href="autodocgen/pysys.writer.testoutput.html#pysys.writer.testoutput.CollectTestOutputWriter" title="pysys.writer.testoutput.CollectTestOutputWriter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.testoutput.CollectTestOutputWriter</span></code></a>. Configure
default values for main configuration properties (by defining them as static variables in your class). Then implement
<a class="reference internal" href="autodocgen/pysys.writer.api.html#pysys.writer.api.BaseResultsWriter.isEnabled" title="pysys.writer.api.BaseResultsWriter.isEnabled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.api.BaseResultsWriter.isEnabled()</span></code></a> to define when coverage reporting will happen, and run the
required processes to combine coverage files and generate a report in the destDir in
<a class="reference internal" href="autodocgen/pysys.writer.api.html#pysys.writer.api.BaseResultsWriter.cleanup" title="pysys.writer.api.BaseResultsWriter.cleanup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.api.BaseResultsWriter.cleanup()</span></code></a>, which will execute after all tests have completed.</p>
<p>Finally, add the new writer class to your <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code> file.</p>
</li>
<li><p>Add the <code class="docutils literal notranslate"><span class="pre">disableCoverage</span></code> group to any tests (or test directories) that should not use coverage,
such as performance tests.</p></li>
<li><p>If using a continuous integration system or centralized code coverage database, you could optionally upload the
coverage data there from the directory PySys collected it into, so there is a permanent record of
any changes in coverage over time. The artifact publishing capability of
<a class="reference internal" href="autodocgen/pysys.writer.testoutput.html#pysys.writer.testoutput.CollectTestOutputWriter" title="pysys.writer.testoutput.CollectTestOutputWriter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.testoutput.CollectTestOutputWriter</span></code></a> will help with that.</p></li>
</ul>
</div>
<div class="section" id="running-tests-in-multiple-modes">
<h2>Running tests in multiple modes<a class="headerlink" href="#running-tests-in-multiple-modes" title="Permalink to this headline">¶</a></h2>
<p>One of the most powerful features of PySys is the ability to run the same test
in multiple modes from a single execution. This could be useful for cases such
as a web test that needs to pass against multiple supported web browsers,
or a set of tests that should be run against various different database but
can also be run against a mocked database for quick local development.</p>
<p>Using modes is fairly straightforward. First edit the <code class="docutils literal notranslate"><span class="pre">pysystest.xml</span></code> files for tests that
need to run in multiple modes, and add a list of the supported modes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">classification</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">groups</span><span class="o">&gt;...&lt;/</span><span class="n">groups</span><span class="o">&gt;</span>
     <span class="o">&lt;</span><span class="n">modes</span> <span class="n">inherit</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">&gt;</span>
             <span class="o">&lt;</span><span class="n">mode</span><span class="o">&gt;</span><span class="n">MockDatabase_Firefox</span><span class="o">&lt;/</span><span class="n">mode</span><span class="o">&gt;</span>
             <span class="o">&lt;</span><span class="n">mode</span><span class="o">&gt;</span><span class="n">MyDatabase2</span><span class="o">.</span><span class="mi">0</span><span class="n">_Chrome</span><span class="o">&lt;/</span><span class="n">mode</span><span class="o">&gt;</span>
     <span class="o">&lt;/</span><span class="n">modes</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">classification</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>When naming modes, TitleCase is recommended, and dot and underscore characters
may be used; typically dot is useful for version numbers and underscore is
useful for separating out different dimensions e.g. database vs web browser
as in the above example. PySys will give an error if you use different
capitalization for the same mode in different places, as this would likely
result in test bugs.</p>
<p>The first mode listed is designated the “primary” mode which means it’s the
one that is used by default when running your tests without a <code class="docutils literal notranslate"><span class="pre">--mode</span></code>
argument. It’s best to choose either the fastest mode or else the one that
is most likely to show up interesting issues as the primary mode.</p>
<p>In large projects you may wish to configure modes in a <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code>
file in a parent directory rather than in <code class="docutils literal notranslate"><span class="pre">pysystest.xml</span></code>, which will by
default be inherited by all nested testcases (unless <code class="docutils literal notranslate"><span class="pre">inherit=&quot;false&quot;</span></code> is
specified in the <code class="docutils literal notranslate"><span class="pre">&lt;modes&gt;</span></code> element), and so there’s a single place to
edit the modes list if you need to change them later. It’s also possible to
create a custom DescriptorLoader subclass that dynamically adds modes
from Python code, perhaps based on the groups specified in each descriptor
or runtime information such as the current operating system.</p>
<p>You can find the mode that this test is running in using <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">self.mode</span></code></a>.
To ensure typos and inconsistencies in individual test descriptor modes do
no go unnoticed, it is best to provide constants for the possible mode values
and/or do validation and unpacking of modes in a test plugin like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestPlugin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testObj</span><span class="p">):</span>
                <span class="c1"># Unpack and validate mode</span>
                <span class="n">testObj</span><span class="o">.</span><span class="n">databaseMode</span><span class="p">,</span> <span class="n">testObj</span><span class="o">.</span><span class="n">browserMode</span> <span class="o">=</span> <span class="n">testObj</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">testObj</span><span class="o">.</span><span class="n">browserMode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Chrome&#39;</span><span class="p">,</span> <span class="s1">&#39;Firefox&#39;</span><span class="p">],</span> <span class="n">testObj</span><span class="o">.</span><span class="n">browserMode</span>

                <span class="c1"># This is a convenient pattern for specifying the method or class</span>
                <span class="c1"># constructor to call for each mode, and to get an exception if an</span>
                <span class="c1"># invalid mode is specified</span>
                <span class="n">dbHelperFactory</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;MockDatabase&#39;</span><span class="p">:</span> <span class="n">MockDB</span><span class="p">,</span>
                        <span class="s1">&#39;MyDatabase2.0&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">startMyDatabase</span><span class="p">(</span><span class="s1">&#39;2.0&#39;</span><span class="p">)</span>
                <span class="p">}[</span><span class="n">testObj</span><span class="o">.</span><span class="n">databaseMode</span><span class="p">]</span>
                <span class="o">...</span>
                <span class="c1"># Call the supplied method to start/configure the database</span>
                <span class="n">testObj</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">dbHelperFactory</span><span class="p">()</span>
</pre></div>
</div>
<p>Finally, PySys provides a rich variety of <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span></code> arguments to control
which modes your tests will run with. By default it will run every test in its
primary mode (for tests with no mode, the primary mode is <code class="docutils literal notranslate"><span class="pre">self.mode==None</span></code>) -
which is great for quick checks during development of your application and
testcases.</p>
<p>Your main test run (perhaps in a CI job) probably wants to run tests in all
modes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pysys</span> <span class="n">run</span> <span class="o">--</span><span class="n">mode</span> <span class="n">ALL</span> <span class="o">--</span><span class="n">threads</span> <span class="n">auto</span>
</pre></div>
</div>
<p>You can also specify specifies modes to run in, or to run everything except
specified modes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pysys run --mode MyMode1,MyMode2
pysys run --mode !MyMode3,!MyMode4
</pre></div>
</div>
<p>After successfully getting all your tests passing in their primary mode, it could
be useful to run them in every mode other than the primary one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pysys run --mode !PRIMARY
</pre></div>
</div>
<p>For reporting purposes, all testcases must have a unique id. With a multiple
mode test this is achieved by having the id automatically include a <code class="docutils literal notranslate"><span class="pre">~Mode</span></code>
suffix. If you are reporting performance results from a multi-mode test, make
sure you include the mode in the <code class="docutils literal notranslate"><span class="pre">resultKey</span></code> when you all <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.reportPerformanceResult" title="pysys.basetest.BaseTest.reportPerformanceResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.reportPerformanceResult</span></code></a>,
since the <code class="docutils literal notranslate"><span class="pre">resultKey</span></code> must be
globally unique.</p>
<p>In addition to the <code class="docutils literal notranslate"><span class="pre">--mode</span></code> argument which affects all selected tests, it is
possible to run a specific test in a specific mode. This can be useful when you
have a few miscellaneous test failures and just want to re-run the failing
tests:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pysys</span> <span class="n">run</span> <span class="n">MyTest_001</span><span class="o">~</span><span class="n">MockDatabase</span> <span class="n">MyTest_020</span><span class="o">~</span><span class="n">MyDatabase_2</span><span class="o">.</span><span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="test-ids-and-structuring-large-projects">
<h2>Test ids and structuring large projects<a class="headerlink" href="#test-ids-and-structuring-large-projects" title="Permalink to this headline">¶</a></h2>
<p>Each test has a unique <code class="docutils literal notranslate"><span class="pre">id</span></code> which is used in various places such as when
reporting passed/failed outcomes. By default the id is just the name of the
directory containing the <code class="docutils literal notranslate"><span class="pre">pysystest.xml</span></code> file.</p>
<p>You can choose a suitable naming convention for your tests. For example,
you might wish to differentiate with just a numeric suffix such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyApp_001</span>
<span class="n">MyApp_002</span>
<span class="n">MyApp_003</span>
</pre></div>
</div>
<p>This has the benefit that it’s easy to refer to tests when communicating with
other developers, and that you can run tests on the command line by specifying
just a number, but you have to look at the test title to discover what it does.</p>
<p>Alternatively you could choose to use a semantically meaningful name for each
test:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyApp_TimeoutValueWorks</span>
<span class="n">MyApp_TimeoutInvalidValuesAreRejected</span>
<span class="n">MyApp_ValidCredentialsAreAccepted</span>
</pre></div>
</div>
<p>These test ids are easier to understand but can’t be referred to as concisely.</p>
<p>Whatever scheme you use for naming test ids, if you have a large set of tests
you will want to separate them out into different directories, so that
related tests can be executed and maintained together. You might have
different directories for different subsystems/parts of your application,
and/or for different kinds of testing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span>  <span class="p">(</span><span class="n">root</span> <span class="nb">dir</span> <span class="n">containing</span> <span class="n">pysysproject</span><span class="o">.</span><span class="n">xml</span><span class="p">)</span>

<span class="o">/</span><span class="n">SubSystem1</span><span class="o">/</span><span class="n">unit</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem1</span><span class="o">/</span><span class="n">correctness</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem1</span><span class="o">/</span><span class="n">long</span><span class="o">-</span><span class="n">running</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem1</span><span class="o">/</span><span class="n">performance</span><span class="o">/</span>

<span class="o">/</span><span class="n">SubSystem2</span><span class="o">/</span><span class="n">unit</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem2</span><span class="o">/</span><span class="n">correctness</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem2</span><span class="o">/</span><span class="n">long</span><span class="o">-</span><span class="n">running</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem2</span><span class="o">/</span><span class="n">performance</span><span class="o">/</span>
<span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>It is important to ensure every test has a unique id. Although it would be
possible to do this by convention in the individual test directory names,
this is fragile and could lead to clashes if someone forgets. Therefore for
large projects it is usually best to add a <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> file to
provide default configuration for each directory of testcases.</p>
<p>For example, in SubSystem1/performance you could create a <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code>
file containing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;pysysdirconfig&gt;
  &lt;id-prefix&gt;SubSystem1_perf.&lt;/id-prefix&gt;

  &lt;classification&gt;
        &lt;groups inherit=&quot;true&quot;&gt;
          &lt;group&gt;subsystem1&lt;/group&gt;
          &lt;group&gt;performance&lt;/group&gt;
          &lt;group&gt;disableCoverage&lt;/group&gt;
        &lt;/groups&gt;

        &lt;modes inherit=&quot;true&quot;&gt;
        &lt;/modes&gt;

  &lt;/classification&gt;

  &lt;execution-order hint=&quot;-100.0&quot;/&gt;

  &lt;!-- Uncomment this to mark all tests under this directory as skipped
        (overrides the state= attribute on individual tests). --&gt;
  &lt;!-- &lt;skipped reason=&quot;&quot;/&gt; --&gt;

&lt;/pysysdirconfig&gt;
</pre></div>
</div>
<p>This serves several useful purposes:</p>
<ul class="simple">
<li><p>It adds a prefix “SubSystem1_perf.” to the beginning of the test directory
names to ensure there’s a unique id for each one with no chance of conflicts
across different directories.</p></li>
<li><p>It adds groups that make it possible to run all your performance tests, or
all your tests for a particular part of the application, in a single command.</p></li>
<li><p>It disables code coverage instrumentation which could adversely affect your
performance results.</p></li>
<li><p>It specifies that the performance tests will be run with a lower priority,
so they execute after more urgent (and quicker) tests such as unit tests.</p></li>
<li><p>It provides the ability to temporarily skip a set of tests if they are
broken temporarily pending a bug fix.</p></li>
</ul>
<p>By default both modes and groups are inherited from <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> files
in parent directories, but inheriting can be disabled in an individual
descriptor by setting <code class="docutils literal notranslate"><span class="pre">inherit=&quot;false&quot;</span></code>, in case you have a few tests that only
make sense in one mode. Alternatively, you could allow the tests to exist
in all modes but call <code class="docutils literal notranslate"><span class="pre">self.skipTest</span> <span class="pre">&lt;BaseTest.skipTest&gt;</span></code> at the start of the test <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.execute" title="pysys.basetest.BaseTest.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.execute</span></code></a> method
if the test cannot execute in the current mode.</p>
<p>See the <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> sample in <code class="docutils literal notranslate"><span class="pre">pysys/xml/templates/dirconfig</span></code>
for a full example of a directory configuration file.</p>
</div>
<div class="section" id="controlling-execution-order">
<h2>Controlling execution order<a class="headerlink" href="#controlling-execution-order" title="Permalink to this headline">¶</a></h2>
<p>In large projects where the test run takes several hours or days, you may wish
to control the order that PySys executes different groups of tests - or tests
with different modes, to maximize the chance of finding out quickly if
something has gone wrong, and perhaps to prioritize running fast unit and
correctness tests before commencing on longer running performance or soak tests.</p>
<p>By default, PySys runs tests based on the sorting them by the full path of
the <code class="xref py py-obj docutils literal notranslate"><span class="pre">pysystest.xml</span></code> files. If you have tests with multiple modes, PySys will
run all tests in their primary mode first, then any/all tests which list a
second mode, followed by 3rd, 4th, etc.</p>
<p>All of this can be customized using the concept of an execution order hint.
Every test descriptor is assigned an execution order hint, which is a positive
or negative floating point number which defaults to 0.0, and is used to sort
the descriptors before execution. Higher execution order hints mean later
execution. If two tests have the same hint, PySys falls back on using the
path of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">pysystest.xml</span></code> file to determine a canonical order.</p>
<p>The hint for each test is generated by adding together hint components from the
following:</p>
<blockquote>
<div><ul class="simple">
<li><p>A test-specific hint from the <code class="docutils literal notranslate"><span class="pre">pysystest.xml</span></code> file’s
<code class="docutils literal notranslate"><span class="pre">&lt;execution-order</span> <span class="pre">hint=&quot;...&quot;/&gt;</span></code>. If the hint is
blank (the default), the test inherits any hint specified in a
<code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> file in an ancestor folder, or 0.0 if there aren’t
any. Note that hints from <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> files are not added
together; instead, the most specific wins.</p></li>
<li><p>All <code class="docutils literal notranslate"><span class="pre">&lt;execution-order&gt;</span></code> elements in the project configuration file which
match the mode and/or group of the test. The project configuration
is the place to put mode-specific execution order hints, such as putting
a particular database or web browser mode earlier/later. See the
sample <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code> file for details.</p></li>
<li><p>For multi-mode tests, the <code class="docutils literal notranslate"><span class="pre">secondaryModesHintDelta</span></code> specified in the project
configuration (unless it’s set to zero), multiplied by a number indicating
which mode this is. If a test had 3 modes Mode1, Mode2 and Mode3 then
the primary mode (Mode1) would get no additional hint, Mode2 would get
<code class="docutils literal notranslate"><span class="pre">secondaryModesHintDelta</span></code> added to its hint and Mode3 would get
<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">secondaryModesHintDelta</span></code> added to its hint. This is the mechanism
PySys uses to ensure all tests run first in their primary mode before
any tests run in their secondary modes. Usually the default value of
<code class="docutils literal notranslate"><span class="pre">secondaryModesHintDelta</span> <span class="pre">=</span> <span class="pre">+100.0</span></code> is useful and avoids the need for too
much mode-specific hint configuration (see above). However if you prefer to
turn it off to have more manual control - or you prefer each test to run
in all modes before moving on to the next test - then simply set
<code class="docutils literal notranslate"><span class="pre">secondaryModesHintDelta</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
</ul>
</div></blockquote>
<p>For really advanced cases, you can programmatically set the
<code class="docutils literal notranslate"><span class="pre">executionOrderHint</span></code> on each descriptor by providing a custom
<a class="reference internal" href="autodocgen/pysys.xml.descriptor.html#pysys.xml.descriptor.DescriptorLoader" title="pysys.xml.descriptor.DescriptorLoader"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.xml.descriptor.DescriptorLoader</span></code></a> or in the constructor of a custom <a class="reference internal" href="autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner" title="pysys.baserunner.BaseRunner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.baserunner.BaseRunner</span></code></a> class.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ProjectConfig.html" class="btn btn-neutral float-right" title="Project Configuration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="BaseTest.html" class="btn btn-neutral float-left" title="The BaseTest Class" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2006-2020 M.B. Grieve; documentation last updated on 2020-08-31

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>