

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Guides &mdash; PySys v2.2  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Project Configuration" href="ProjectConfiguration.html" />
    <link rel="prev" title="The BaseTest Class" href="BaseTest.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PySys v2.2
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="BaseTest.html">The BaseTest Class</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#how-to">How to</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#detect-the-platform">Detect the platform</a></li>
<li class="toctree-l3"><a class="reference internal" href="#skip-tests">Skip tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#check-for-error-messages-in-log-files">Check for error messages in log files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-new-test-templates-for-pysys-make">Create new test templates for pysys make</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#concepts-and-techniques">Concepts and techniques</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sharing-logic-across-tests-using-helpers">Sharing logic across tests using helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-tests-in-multiple-modes">Running tests in multiple modes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-modes-for-parameterized-tests">Using modes for parameterized tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-modes-for-other-purposes">Using modes for other purposes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#executing-modes-with-pysys-run">Executing modes with pysys run</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#performance-testing">Performance testing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#recording-results">Recording results</a></li>
<li class="toctree-l4"><a class="reference internal" href="#designing-performance-tests">Designing performance tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-performance-tests">Running performance tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparing-performance-results">Comparing performance results</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#test-ids-and-structuring-large-projects">Test ids and structuring large projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#controlling-execution-order">Controlling execution order</a></li>
<li class="toctree-l3"><a class="reference internal" href="#runner-and-writer-plugins">Runner and writer plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-and-overriding-test-options">Configuring and overriding test options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thread-safety">Thread-safety</a></li>
<li class="toctree-l3"><a class="reference internal" href="#producing-code-coverage-reports">Producing code coverage reports</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ProjectConfiguration.html">Project Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="TestDescriptors.html">Test Descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../autodocgen/pysys.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ChangeLog.html">Change Log</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySys v2.2</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Guides</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/pysys/UserGuide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="guides">
<h1>Guides<a class="headerlink" href="#guides" title="Permalink to this headline">¶</a></h1>
<div class="section" id="how-to">
<h2>How to<a class="headerlink" href="#how-to" title="Permalink to this headline">¶</a></h2>
<div class="section" id="detect-the-platform">
<h3>Detect the platform<a class="headerlink" href="#detect-the-platform" title="Permalink to this headline">¶</a></h3>
<p>It’s very common to have one set of logic for Windows and another for
all non-Windows (Unix-based) platforms, and PySys has a dedicated constant <a class="reference internal" href="../autodocgen/pysys.constants.html#pysys.constants.IS_WINDOWS" title="pysys.constants.IS_WINDOWS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.constants.IS_WINDOWS</span></code></a> for
that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">startProcess</span><span class="p">(</span><span class="s1">&#39;myprogram.exe&#39;</span> <span class="k">if</span> <span class="n">IS_WINDOWS</span> <span class="k">else</span> <span class="s1">&#39;myprogram&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>For finer grained platform detection we recommend using the facilities built into Python, for example
<code class="docutils literal notranslate"><span class="pre">sys.platform</span></code>, <code class="docutils literal notranslate"><span class="pre">platform.platform()</span></code> or <code class="docutils literal notranslate"><span class="pre">platform.uname()</span></code>.</p>
</div>
<div class="section" id="skip-tests">
<h3>Skip tests<a class="headerlink" href="#skip-tests" title="Permalink to this headline">¶</a></h3>
<p>If your tests’ <code class="docutils literal notranslate"><span class="pre">.py</span></code> logic detects that a test should not be executed for this
platform or mode, simply use <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.skipTest" title="pysys.basetest.BaseTest.skipTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">self.skipTest(...)</span></code></a> near the top of the test’s
<a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.execute" title="pysys.basetest.BaseTest.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute()</span></code></a> method, specifying the reason for the skip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s1">&#39;MyFeature is not supported on Windows&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As well as setting the test outcome and reason, this will raise an exception
ensuring that the rest of <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.execute" title="pysys.basetest.BaseTest.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">execute()</span></code></a> and
<a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.validate" title="pysys.basetest.BaseTest.validate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">validate()</span></code></a> do not get executed.</p>
<p>Alternatively if the test should be skipped regardless of platform/mode etc,
it is best to specify that statically in your <code class="xref py py-obj docutils literal notranslate"><span class="pre">pysystest.*</span></code> file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__pysys_skipped_reason__</span>   <span class="o">=</span> <span class="s2">&quot;Skipped until Bug-1234 is fixed&quot;</span>
</pre></div>
</div>
<p>Or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">skipped</span> <span class="n">reason</span><span class="o">=</span><span class="s2">&quot;Skipped until Bug-1234 is fixed&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="check-for-error-messages-in-log-files">
<h3>Check for error messages in log files<a class="headerlink" href="#check-for-error-messages-in-log-files" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.assertGrep" title="pysys.basetest.BaseTest.assertGrep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.assertGrep</span></code></a> method is an easy way to check that there are no error
messages in log files from processes started by PySys. Rather than checking for
an expression such as <code class="xref py py-obj docutils literal notranslate"><span class="pre">'</span> <span class="pre">ERROR:</span> <span class="pre">'</span></code>, it is recommended to define your expression
so that the error message itself is included, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertGrep</span><span class="p">(</span><span class="s1">&#39;myprocess.log&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="s1">&#39; ERROR: .*&#39;</span><span class="p">,</span> <span class="n">contains</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>This approach ensures that the error message itself is included in the test’s
console output, run.log and the summary of failed test outcomes, which avoids
the need to open up the individual logs to find out what happened, and makes it
much easier to triage test failures, especially if several tests fail for the
same reason.</p>
</div>
<div class="section" id="create-new-test-templates-for-pysys-make">
<h3>Create new test templates for pysys make<a class="headerlink" href="#create-new-test-templates-for-pysys-make" title="Permalink to this headline">¶</a></h3>
<p>You can define templates that <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">make</span></code> will use to create new tests specific to your project, or even multiple
templates for individual directories within your project. This helps to encourage teams to follow the latest best
practice by ensuring new tests are copying known good patterns, and also saves looking up how to do common things when
creating new tests.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">make</span></code> command line comes with a <code class="docutils literal notranslate"><span class="pre">pysys-default-test</span></code> template for creating a simple PySys test, you can
add your own by adding <code class="docutils literal notranslate"><span class="pre">&lt;maker-template&gt;</span></code> elements to <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> in any directory under your project,
or to a <code class="docutils literal notranslate"><span class="pre">&lt;pysysdirconfig&gt;</span></code> element in your <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code> file. Here are a few examples (taken from
the cookbook sample):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">pysysdirconfig</span><span class="o">&gt;</span>

        <span class="o">&lt;</span><span class="n">maker</span><span class="o">-</span><span class="n">template</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my-test&quot;</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;a test with the Python code pre-customized to get things started&quot;</span>
                <span class="n">copy</span><span class="o">=</span><span class="s2">&quot;./_pysys_templates/MyTemplateTest/*&quot;</span> <span class="o">/&gt;</span>

        <span class="o">&lt;</span><span class="n">maker</span><span class="o">-</span><span class="n">template</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;perf-test&quot;</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;a performance test including configuration for my fictional performance tool&quot;</span>
                <span class="n">copy</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{pysysTemplatesDir}</span><span class="s2">/default-test/*, ./_pysys_templates/perf/my-perf-config.xml&quot;</span><span class="o">/&gt;</span>

        <span class="o">&lt;</span><span class="n">maker</span><span class="o">-</span><span class="n">template</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;foobar-test&quot;</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;an advanced test based on the existing XXX test&quot;</span>
                <span class="n">copy</span><span class="o">=</span><span class="s2">&quot;./PySysDirConfigSample/*&quot;</span>
                <span class="n">mkdir</span><span class="o">=</span><span class="s2">&quot;ExtraDir1, ExtraDir2&quot;</span>
        <span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="n">replace</span> <span class="n">regex</span><span class="o">=</span><span class="s1">&#39;__pysys_title__ *= r&quot;&quot;&quot;[^&quot;]*&quot;&quot;&quot;&#39;</span> <span class="k">with</span><span class="o">=</span><span class="s1">&#39;__pysys_title__   = r&quot;&quot;&quot; Foobar - My new @</span><span class="si">{DIR_NAME}</span><span class="s1"> test title TODO &quot;&quot;&quot;&#39;</span><span class="o">/&gt;</span>
                <span class="o">&lt;</span><span class="n">replace</span> <span class="n">regex</span><span class="o">=</span><span class="s1">&#39;__pysys_authors__ *= &quot;[^&quot;]*&quot;&#39;</span>    <span class="k">with</span><span class="o">=</span><span class="s1">&#39;__pysys_authors__ = &quot;@</span><span class="si">{USERNAME}</span><span class="s1">&quot;&#39;</span><span class="o">/&gt;</span>
                <span class="o">&lt;</span><span class="n">replace</span> <span class="n">regex</span><span class="o">=</span><span class="s1">&#39;__pysys_created__ *= &quot;[^&quot;]*&quot;&#39;</span>    <span class="k">with</span><span class="o">=</span><span class="s1">&#39;__pysys_created__ = &quot;@</span><span class="si">{DATE}</span><span class="s1">&quot;&#39;</span><span class="o">/&gt;</span>
                <span class="o">&lt;</span><span class="n">replace</span> <span class="n">regex</span><span class="o">=</span><span class="s1">&#39;@@DIR_NAME@@&#39;</span>                    <span class="k">with</span><span class="o">=</span><span class="s1">&#39;@</span><span class="si">{DIR_NAME}</span><span class="s1">&#39;</span><span class="o">/&gt;</span>
        <span class="o">&lt;/</span><span class="n">maker</span><span class="o">-</span><span class="n">template</span><span class="o">&gt;</span>

<span class="o">&lt;/</span><span class="n">pysysdirconfig</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>For customizing the PySysTest class the best approach is usually to create a <code class="docutils literal notranslate"><span class="pre">pysystest.py</span></code> template test
containing <code class="docutils literal notranslate"><span class="pre">&#64;&#64;DEFAULT_DESCRIPTOR&#64;&#64;</span></code> (or <code class="xref py py-obj docutils literal notranslate"><span class="pre">&#64;&#64;DEFAULT_DESCRIPTOR_MINIMAL&#64;&#64;</span></code>) to include the default PySys descriptor
values (this means your template will automatically benefit from any future changes to the defaults), and put it in a
<code class="docutils literal notranslate"><span class="pre">_pysys_templates/&lt;templatename&gt;</span></code> directory alongside the <code class="docutils literal notranslate"><span class="pre">pysystestdir.xml</span></code> file.
The <code class="docutils literal notranslate"><span class="pre">_pysys_templates</span></code> directory should contain a file named <code class="docutils literal notranslate"><span class="pre">.pysysignore</span></code> file (which avoids the template being
loaded as a real test).</p>
<p>Other options are possible (as above) e.g. copying files from an absolute location such as under your project’s
<code class="docutils literal notranslate"><span class="pre">${testRootDir}</span></code>, copying from PySys default templates directly (if you just want to <em>add</em> files) by
using <code class="docutils literal notranslate"><span class="pre">${pysysTemplatesDir}/default-test/*</span></code>, or copying from a path relative to the XML file where the template is
defined containing a real (but simple) test to copy from (with suitable regex replacements to make it more generic).</p>
<p>See <a class="reference internal" href="TestDescriptors.html#sample-pysysdirconfig-xml"><span class="std std-ref">Sample pysysdirconfig.xml</span></a> for more information about how to configure templates in
a <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> file.</p>
<p>When creating tests using <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">make</span></code>, by default the first template (from the most specific <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code>)
is selected, but you can also specify any other template by name using the <code class="docutils literal notranslate"><span class="pre">-t</span></code> option, and get a list of available
templates for the current directory using <code class="docutils literal notranslate"><span class="pre">--help</span></code>. You can also customize which is the default template for a
given directory by naming a template defined at a higher level (for example in the project) like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">pysysdirconfig</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nb">set</span><span class="o">-</span><span class="n">default</span><span class="o">-</span><span class="n">maker</span><span class="o">-</span><span class="n">template</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my-inherited-test-template&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">pysysdirconfig</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>It is possible to subclass the <a class="reference internal" href="../autodocgen/pysys.launcher.console_make.html#pysys.launcher.console_make.DefaultTestMaker" title="pysys.launcher.console_make.DefaultTestMaker"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.launcher.console_make.DefaultTestMaker</span></code></a> responsible for this logic if needed.
The main reason to do that is to provide a <a class="reference internal" href="../autodocgen/pysys.launcher.console_make.html#pysys.launcher.console_make.DefaultTestMaker.validateTestId" title="pysys.launcher.console_make.DefaultTestMaker.validateTestId"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.launcher.console_make.DefaultTestMaker.validateTestId</span></code></a> method
to check that new test ids do not conflict with others used by others in a remote version control system (to avoid
merge conflicts).</p>
<p>By default PySys creates <code class="docutils literal notranslate"><span class="pre">.py</span></code> files with tabs for indentation (as in previous PySys releases). If you prefer spaces,
just set the <code class="docutils literal notranslate"><span class="pre">pythonIndentationSpacesPerTab</span></code> project property to a string containing the required spaces per tab.</p>
</div>
</div>
<div class="section" id="concepts-and-techniques">
<h2>Concepts and techniques<a class="headerlink" href="#concepts-and-techniques" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sharing-logic-across-tests-using-helpers">
<h3>Sharing logic across tests using helpers<a class="headerlink" href="#sharing-logic-across-tests-using-helpers" title="Permalink to this headline">¶</a></h3>
<p>Often you will have some standard logic that needs to be used in the execute or validation
of many/all testcases, such as starting the application you’re testing, or checking log files for errors.</p>
<p>The recommended way to do that in PySys is to create modular, independent helper classes that are included
in the tests that need them using inheritance (via the “mix-in” pattern). A key constraint
is that the helper classes themselves contain only a single field holding an instance that encapsulates all the
real functionality - this avoid name clashes between different helpers, and with the PySys BaseTest class itself.</p>
<p>The best way to add one is to copy from the <strong>getting-started</strong> sample where there is a <code class="docutils literal notranslate"><span class="pre">MyServerHelper</span></code> mix-in class
that provides a field called <code class="docutils literal notranslate"><span class="pre">self.myserver</span></code> through which all of the real functionality is encapsulated and exposed
to individual tests for reuse. To use it in a test all you need to do is inherit the helper in any tests that need it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myorg.myserverhelper</span> <span class="kn">import</span> <span class="n">MyServerHelper</span>
<span class="k">class</span> <span class="nc">PySysTest</span><span class="p">(</span><span class="n">MyServerHelper</span><span class="p">,</span> <span class="n">pysys</span><span class="o">.</span><span class="n">basetest</span><span class="o">.</span><span class="n">BaseTest</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">server</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">myserver</span><span class="o">.</span><span class="n">startServer</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;my_server&quot;</span><span class="p">)</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Since this approach uses standard Python, any IDE will be able to give assistance for the myserver methods (provided your extension
classes are on its configured PYTHONPATH).</p>
<p>Any number of helpers can be added to each test that needs them. Just ensure that the BaseTest class is listed last in the list of
classes your test inherits from.</p>
<p>This approach has significant advantages over these alternatives that were used in the past:</p>
<ul class="simple">
<li><p>Custom BaseTest subclasses. In this paradigm, PySys methods/fields exist in the same namespace as the custom ones, creating a
risk of clashes and unexpected bugs and upgrade pain. Moreover as your project grows you will often end up with multiple
BaseTest subclasses for different parts of your testing, and there is a high chance that functionality that seemed to belong
in one place will one day be needed in a different sibling BaseTest, leading to a need to refactor or complex multiple
inheritance headaches. Using the composition approach of the “helper” classes avoids this complexity and keeps your test
extensions nice and clean.</p></li>
<li><p>Test plugins. These were introduced in older PySys versions to solve the encapsulation problem, but it is now recommended to
avoid them because Python IDEs are not able to resolve them, leading to errors or at least a lack of code assistance when
interacting with the plugin in your tests.</p></li>
</ul>
</div>
<div class="section" id="running-tests-in-multiple-modes">
<h3>Running tests in multiple modes<a class="headerlink" href="#running-tests-in-multiple-modes" title="Permalink to this headline">¶</a></h3>
<p>One of the powerful features of PySys is the ability to run the same test in multiple modes from a single execution.
This can be useful for both parameterized tests, where the same Python logic is invoked with multiple different
parameters to test a range of scenarios, and for running tests against different databases, web browsers etc.</p>
<p>In PySys, a mode consists of a mode name, and a dictionary of parameters with detailed information about how to
execute in that mode. The Python test can use <code class="docutils literal notranslate"><span class="pre">self.mode.params</span></code> to access the parameter dictionary, and <code class="docutils literal notranslate"><span class="pre">self.mode</span></code>
to get the mode name.</p>
<p>During test execution, output files are kept separate by having mode executed from a different output directory,
suffixed by <code class="docutils literal notranslate"><span class="pre">~ModeName</span></code>.</p>
<p>When naming modes, TitleCase is recommended, and dot, underscore and equals characters
may be used. Typically dot is useful for version numbers and underscore <code class="docutils literal notranslate"><span class="pre">_</span></code> is
useful for separating out different dimensions (e.g. compression vs authentication type
in the example described later in this section). Separating dimensions cleanly in this way will make it
much easier to include/exclude the test modes you want. PySys will give an error if you use different
capitalization for the same mode in different places, as this can result in test bugs.</p>
<div class="section" id="using-modes-for-parameterized-tests">
<h4>Using modes for parameterized tests<a class="headerlink" href="#using-modes-for-parameterized-tests" title="Permalink to this headline">¶</a></h4>
<p>Parameterized tests provide a convenient way to re-use the same Python logic to check multiple different testing
scenarios. This avoids the maintenance headache of copy+pasted testcases, and provides faster and more granular test
outcomes than combining all the different parameters into a single test with a big <code class="docutils literal notranslate"><span class="pre">for</span></code> loop.</p>
<p>To specify modes for a parameterized test, just edit the <code class="docutils literal notranslate"><span class="pre">pysystest.*</span></code> file for your test, and
provide a dictionary of <code class="docutils literal notranslate"><span class="pre">ModeName:</span> <span class="pre">{ParameterDict}</span></code> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__pysys_parameterized_test_modes__</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;Usage&#39;</span><span class="p">:</span>        <span class="p">{</span><span class="s1">&#39;cmd&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;--help&#39;</span><span class="p">],</span> <span class="s1">&#39;expectedExitStatus&#39;</span><span class="p">:</span><span class="s1">&#39;==0&#39;</span><span class="p">},</span>
                <span class="s1">&#39;BadPort&#39;</span><span class="p">:</span>      <span class="p">{</span><span class="s1">&#39;cmd&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;--port&#39;</span><span class="p">,</span> <span class="s1">&#39;-1&#39;</span><span class="p">],</span>  <span class="s1">&#39;expectedExitStatus&#39;</span><span class="p">:</span><span class="s1">&#39;!=0&#39;</span><span class="p">},</span>
                <span class="s1">&#39;MissingPort&#39;</span><span class="p">:</span>  <span class="p">{</span><span class="s1">&#39;cmd&#39;</span><span class="p">:</span> <span class="p">[],</span>  <span class="s1">&#39;expectedExitStatus&#39;</span><span class="p">:</span><span class="s1">&#39;!=0&#39;</span><span class="p">},</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>This produces a test with 3 modes - named <code class="docutils literal notranslate"><span class="pre">Usage</span></code>, <code class="docutils literal notranslate"><span class="pre">BadPort</span></code> and <code class="docutils literal notranslate"><span class="pre">MissingPort</span></code> - for the various scenarios
being checked. As you can see, it is possible to provide both input data, and data for use during validation.
The test can easily access the parameters using expressions such as <code class="docutils literal notranslate"><span class="pre">self.mode.params[&quot;cmd&quot;]</span></code>.</p>
<p>It is also possible to provide the exact same configuration using the more advanced <code class="docutils literal notranslate"><span class="pre">__pysys_modes__</span></code> field described
below, however <code class="docutils literal notranslate"><span class="pre">__pysys_parameterized_test_modes__</span></code> is easier for this use case, and automatically takes care of
marking the parameterized modes as “primary” (so they will all run by default even specifying a <code class="docutils literal notranslate"><span class="pre">--modes</span></code> argument),
and combining them with any inherited modes (e.g. for different databases, browsers, etc).</p>
</div>
<div class="section" id="using-modes-for-other-purposes">
<h4>Using modes for other purposes<a class="headerlink" href="#using-modes-for-other-purposes" title="Permalink to this headline">¶</a></h4>
<p>Modes can also be used for making your test run with different databases, web browsers, and other execution
environments.</p>
<p>Often for these use cases you will want more control than parameterized tests give, for example
it is likely you’ll want to execute with one database/browser in local test runs (probably the fastest one!) so
you would not want all of them marked as primary modes. Additionally for these use cases the modes are often defined
at a directory level for a collection of testcases rather in each individual test. You may also need precise control
over which of the modes from a parent directory are inherited, since some modes may not be applicable to all tests.</p>
<p>All of these cases and more can be handled by the <code class="docutils literal notranslate"><span class="pre">__pysys_modes__</span></code> configuration, which allows you to return a
Python expression that returns the list (or dict) of modes for each test and/or <code class="docutils literal notranslate"><span class="pre">pysysdirconfig</span></code>. Since you will
often need access to the inherited modes and (other useful methods and data) when defining your mode list,
a <code class="docutils literal notranslate"><span class="pre">helper</span></code> object (<a class="reference internal" href="../autodocgen/pysys.config.descriptor.html#pysys.config.descriptor.TestModesConfigHelper" title="pysys.config.descriptor.TestModesConfigHelper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.config.descriptor.TestModesConfigHelper</span></code></a>) is made available to your modes expression by the
use of a Python lambda expression.</p>
<p>If you want to add some new modes in addition to the inherited ones, you would add this to your <code class="docutils literal notranslate"><span class="pre">pysystest.py</span></code> file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">__pysys_modes__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">helper</span><span class="p">:</span> <span class="n">helper</span><span class="o">.</span><span class="n">inheritedModes</span><span class="o">+</span><span class="p">[</span>
                <span class="p">{</span><span class="s1">&#39;mode&#39;</span><span class="p">:</span><span class="s1">&#39;CompressionGZip&#39;</span><span class="p">,</span> <span class="s1">&#39;compressionType&#39;</span><span class="p">:</span><span class="s1">&#39;gzip&#39;</span><span class="p">},</span>
        <span class="p">]</span>
</pre></div>
</div>
<p>In large projects you may wish to configure modes in a <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code>
file in a parent directory rather than in <code class="docutils literal notranslate"><span class="pre">pysystest.*</span></code>, which will by
default be inherited by all nested testcases (unless an explicit modes
configuration is provided), and so that there’s a single place to edit the modes
list if you need to change them later.</p>
<p>By default the first mode in each list is “primary”, so the test will only run in that one primary mode by
default during local test runs (i.e. unless you supply a <code class="docutils literal notranslate"><span class="pre">--modes</span></code> or <code class="docutils literal notranslate"><span class="pre">--ci</span></code> argument). This is optimal when
using modes to validate the same behaviour/conditions in different execution environments e.g.
browsers/databases etc (but not for parameterized tests where you usually want to run all of them). It’s best to choose
either the fastest mode or else the one that is most likely to show up interesting issues as the primary mode.</p>
<p>Sometimes your modes will have multiple dimensions, such as database, web browser, compression type, authentication
type etc, and you may want your tests to run in all combinations of each item in each dimension list.
Rather than writing out every combination manually, you can use the helper function
<a class="reference internal" href="../autodocgen/pysys.config.descriptor.html#pysys.config.descriptor.TestModesConfigHelper.createModeCombinations" title="pysys.config.descriptor.TestModesConfigHelper.createModeCombinations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.config.descriptor.TestModesConfigHelper.createModeCombinations</span></code></a> to automatically generate the combinations,
passing it each dimension (e.g. each compression type) as a separate list.</p>
<p>Here is an example of multi-dimensional modes (taken from the getting-started sample):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">__pysys_modes__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">helper</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">mode</span> <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span>
                        <span class="n">helper</span><span class="o">.</span><span class="n">createModeCombinations</span><span class="p">(</span> <span class="c1"># Takes any number of mode lists as arguments and returns a single combined mode list</span>

                                <span class="n">helper</span><span class="o">.</span><span class="n">inheritedModes</span><span class="p">,</span>

                                <span class="p">{</span>
                                                <span class="s1">&#39;CompressionNone&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;compressionType&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;isPrimary&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">},</span>
                                                <span class="s1">&#39;CompressionGZip&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;compressionType&#39;</span><span class="p">:</span><span class="s1">&#39;gzip&#39;</span><span class="p">},</span>
                                <span class="p">},</span>

                                <span class="p">[</span>
                                        <span class="p">{</span><span class="s1">&#39;auth&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">},</span> <span class="c1"># Mode name is optional</span>
                                        <span class="p">{</span><span class="s1">&#39;auth&#39;</span><span class="p">:</span><span class="s1">&#39;OS&#39;</span><span class="p">},</span> <span class="c1"># In practice auth=OS modes will always be excluded since MyFunkyOS is a fictional OS</span>
                                <span class="p">],</span>

                <span class="c1"># This is Python list comprehension syntax for filtering the items in the list</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">[</span><span class="s1">&#39;auth&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;OS&#39;</span> <span class="ow">or</span> <span class="n">helper</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;sys&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;MyFunkyOS&#39;</span><span class="p">)</span>
        <span class="p">]</span>
</pre></div>
</div>
<p>This will create the following modes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CompressionNone_Auth</span><span class="o">=</span><span class="n">None_Usage</span>       <span class="p">[</span><span class="n">PRIMARY</span><span class="p">]</span>
<span class="n">CompressionNone_Auth</span><span class="o">=</span><span class="n">None_BadPort</span>     <span class="p">[</span><span class="n">PRIMARY</span><span class="p">]</span>
<span class="n">CompressionNone_Auth</span><span class="o">=</span><span class="n">None_MissingPort</span> <span class="p">[</span><span class="n">PRIMARY</span><span class="p">]</span>
<span class="n">CompressionGZip_Auth</span><span class="o">=</span><span class="n">None_Usage</span>
<span class="n">CompressionGZip_Auth</span><span class="o">=</span><span class="n">None_BadPort</span>
<span class="n">CompressionGZip_Auth</span><span class="o">=</span><span class="n">None_MissingPort</span>
<span class="n">CompressionNone_OS_Usage</span>
<span class="n">CompressionNone_OS_BadPort</span>
<span class="n">CompressionNone_OS_MissingPort</span>
<span class="n">CompressionGZip_OS_Usage</span>
<span class="n">CompressionGZip_OS_BadPort</span>
<span class="n">CompressionGZip_OS_MissingPort</span>
</pre></div>
</div>
<p>When creating multi-dimensional modes you can explicitly specify the name of each mode using <code class="docutils literal notranslate"><span class="pre">'mode':..</span></code>, but
if you want to avoid repeating the value of your parameters you can let PySys generate a default mode, which
it does by taking each parameter concatenated with <code class="docutils literal notranslate"><span class="pre">_</span></code>; parameters with non-string values (e.g. <code class="docutils literal notranslate"><span class="pre">None</span></code> in
the above example) are additionally qualified with <code class="docutils literal notranslate"><span class="pre">paramName=</span></code> to make the meaning clear.</p>
<p>The above example also shows how a Python list comprehension can be used to filter prevent the Auth=OS modes
from being added on some operation systems (in this example, on all non-fictional operating systems!).</p>
<p>You can find the mode that this test is running in using <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">self.mode</span></code></a>, which returns an instance of
<a class="reference internal" href="../autodocgen/pysys.config.descriptor.html#pysys.config.descriptor.TestMode" title="pysys.config.descriptor.TestMode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.config.descriptor.TestMode</span></code></a> that subclasses a <code class="docutils literal notranslate"><span class="pre">str</span></code> of the mode name, as well as the parameters
via a <code class="docutils literal notranslate"><span class="pre">params</span></code> field.</p>
<p>You can also use Python list comprehensions to generate sets of modes from a <code class="docutils literal notranslate"><span class="pre">range</span></code> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">__pysys_modes__</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">helper</span><span class="p">:</span> <span class="n">helper</span><span class="o">.</span><span class="n">createModeCombinations</span><span class="p">(</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">inheritedModes</span><span class="p">,</span>
                <span class="p">[</span> <span class="p">{</span><span class="s1">&#39;mode&#39;</span><span class="p">:</span><span class="s1">&#39;CompressionGZip&#39;</span><span class="p">,</span> <span class="s1">&#39;compressionType&#39;</span><span class="p">:</span><span class="s1">&#39;gzip&#39;</span><span class="p">},</span> <span class="p">],</span>
                <span class="p">[</span> <span class="p">{</span><span class="s1">&#39;serverThreads&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">}</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">],</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>Here’s an example showing how a test plugin might use modes configuration to configure the test object
during test setup:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestPlugin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testObj</span><span class="p">):</span>
                <span class="c1"># This is a convenient pattern for specifying the method or class</span>
                <span class="c1"># constructor to call for each mode, and to get an exception if an</span>
                <span class="c1"># invalid mode is specified</span>
                <span class="n">dbHelperFactory</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;MockDatabase&#39;</span><span class="p">:</span> <span class="n">MockDB</span><span class="p">,</span>
                        <span class="s1">&#39;MyDatabase2.0&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">startMyDatabase</span><span class="p">(</span><span class="s1">&#39;2.0&#39;</span><span class="p">)</span>
                <span class="p">}[</span><span class="n">testObj</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;database&#39;</span><span class="p">]]</span>
                <span class="o">...</span>
                <span class="c1"># Call the supplied method to start/configure the database</span>
                <span class="n">testObj</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">dbHelperFactory</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="executing-modes-with-pysys-run">
<h4>Executing modes with pysys run<a class="headerlink" href="#executing-modes-with-pysys-run" title="Permalink to this headline">¶</a></h4>
<p>PySys provides a rich variety of <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span></code> arguments to control
which modes your tests will run with. By default it will run every test in its
primary modes (for tests with no mode, the primary mode is <code class="docutils literal notranslate"><span class="pre">self.mode==None</span></code>) -
which is great for quick checks during development of your application and
testcases.</p>
<p>Your main test run (perhaps in a CI job) probably wants to run tests in all
modes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pysys</span> <span class="n">run</span> <span class="o">--</span><span class="n">mode</span> <span class="n">ALL</span>
</pre></div>
</div>
<p>(In practice you would use <code class="docutils literal notranslate"><span class="pre">--ci</span></code> which does the above and also sets some other useful defaults).</p>
<p>You can also specify specifies modes to run in, or to run everything except
specified modes, or even use regular expressions for even more flexibility:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pysys run --mode MyMode1,MyMode2
pysys run --mode !MyMode3,!MyMode4
pysys run --mode MyMode.*
</pre></div>
</div>
<p>After successfully getting all your tests passing in their primary modes, it could
be useful to run them in every mode other than the primary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>pysys run --mode !PRIMARY
</pre></div>
</div>
<p>For reporting purposes, all testcases must have a unique id. With a multiple
mode test this is achieved by having the id automatically include a <code class="docutils literal notranslate"><span class="pre">~Mode</span></code>
suffix. If you are reporting performance results from a multi-mode test, make
sure you include the mode in the <code class="docutils literal notranslate"><span class="pre">resultKey</span></code> when you all <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.reportPerformanceResult" title="pysys.basetest.BaseTest.reportPerformanceResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.reportPerformanceResult</span></code></a>,
since the <code class="docutils literal notranslate"><span class="pre">resultKey</span></code> must be globally unique.</p>
<p>In addition to the <code class="docutils literal notranslate"><span class="pre">--mode</span></code> argument which affects all selected tests, it is
possible to run a specific test in a specific mode. This can be useful when you
have a few miscellaneous test failures and just want to re-run the failing
tests:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pysys</span> <span class="n">run</span> <span class="n">MyTest_001</span><span class="o">~</span><span class="n">MockDatabase</span> <span class="n">MyTest_020</span><span class="o">~</span><span class="n">MyDatabase_2</span><span class="mf">.0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="performance-testing">
<h3>Performance testing<a class="headerlink" href="#performance-testing" title="Permalink to this headline">¶</a></h3>
<div class="section" id="recording-results">
<h4>Recording results<a class="headerlink" href="#recording-results" title="Permalink to this headline">¶</a></h4>
<p>PySys is a great tool for running performance tests, whether unit-level microbenchmarks or complex multi-process
full system benchmarking.</p>
<p>Often performance tests will produced detailed output files (XML/JSON/PDF/logs etc) that are worth capturing for
analysis by a human, or for storing as a long term audit of how this build performed. To do this, you can add a
<a class="reference internal" href="../autodocgen/pysys.writer.testoutput.html#pysys.writer.testoutput.CollectTestOutputWriter" title="pysys.writer.testoutput.CollectTestOutputWriter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.testoutput.CollectTestOutputWriter</span></code></a> to your project configuration. This writer collects files matching a
specified pattern from the output directory after each test, and puts them in a single directory or archive at the
end of the test run.</p>
<p>Whether or not you have some detailed files to stash, it is worth also using <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.reportPerformanceResult" title="pysys.basetest.BaseTest.reportPerformanceResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.reportPerformanceResult</span></code></a>, the
powerful built-in capability for storing some summary numbers for each test. In complex tests you probably
won’t want to record every possible statistic - since that can quickly overwhelm once the total number of number of
tests grows; a better strategy is to select a few representative data points from each test/mode combination.
By default the numeric results are written to a CSV file (along with the runner’s <code class="docutils literal notranslate"><span class="pre">runDetails</span></code> dictionary including
things like OS, CPU count, hostname and git commit of your source changes). There is also a reporter available for
writing in a simple JSON format, and another that produces a textual summary of the results at the end of the run.
You can also create your own reporters (e.g. to publish to an in-house database) using the <a class="reference internal" href="../autodocgen/pysys.perf.html#module-pysys.perf" title="pysys.perf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.perf</span></code></a> API.</p>
<p>The <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.reportPerformanceResult" title="pysys.basetest.BaseTest.reportPerformanceResult"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.reportPerformanceResult</span></code></a> documentation gives the details, but one point that’s worth stressing is that
every result should be identified by a short, unique, human-friendly <code class="docutils literal notranslate"><span class="pre">resultKey</span></code> which should give an at-a-glance
definition of what is being recorded such as
<code class="docutils literal notranslate"><span class="pre">Message</span> <span class="pre">send</span> <span class="pre">rate</span> <span class="pre">with</span> <span class="pre">3</span> <span class="pre">topics</span> <span class="pre">and</span> <span class="pre">small</span> <span class="pre">100kB</span> <span class="pre">messages</span> <span class="pre">using</span> <span class="pre">MyMessagingVendor</span></code>.
For maximum benefit, design your keys so that when sorted (imagine a big list of 100+ numbers from all your testcases!)
you’ll see closely related results next to each other. These keys must be unique - so if a test runs in multiple modes
(e.g. messaging/database vendors) then you must add some kind of string to the result key to indicate which it is
running in, otherwise PySys will raise an exception and not persist the result. See the samples for some examples of
using this API.</p>
</div>
<div class="section" id="designing-performance-tests">
<h4>Designing performance tests<a class="headerlink" href="#designing-performance-tests" title="Permalink to this headline">¶</a></h4>
<p>Often a performance test will run for a bit longer than a simple correctness test, for example it might have a set
number of iterations or time duration. See the above section “Configuring and overriding test options” for an example
of how to make it easy to customize the iteration count/duration at runtime e.g. <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span> <span class="pre">-XmyIterationCount=10</span></code>.
You may find you want to run your test super-quick in the early stages until it executes the steps correctly. When
tracking down performance problems you might want to try running it for longer than usual to get more reliable results.</p>
<p>It is common to have a single performance test that should run with different parameters, for example against different
databases, or perhaps with a variety of incoming message sizes. Avoid copy+pasting tests for this use case (which would
be a maintenance nightmare). It is also a bad idea to add a giant “for” loop into your test and make it do everything in
one invocation, since then it’s very difficult to surgically re-run problematic parts of your parameter matrix when
tracking down test bugs or optimizing your application. Instead use the built-in “modes” concept of PySys which is
perfect for the job. It can even generate a combinatoric product of various different parameter dimensions for you
with <a class="reference internal" href="../autodocgen/pysys.config.descriptor.html#pysys.config.descriptor.TestModesConfigHelper.createModeCombinations" title="pysys.config.descriptor.TestModesConfigHelper.createModeCombinations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.config.descriptor.TestModesConfigHelper.createModeCombinations</span></code></a> as described above.</p>
</div>
<div class="section" id="running-performance-tests">
<h4>Running performance tests<a class="headerlink" href="#running-performance-tests" title="Permalink to this headline">¶</a></h4>
<p>When running performance tests from an automated job, it is important to ensure that you do not have multiple
tests executing at once since this will usually invalidate the results. It is therefore best to run your performance
tests in a separate <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span></code> invocation to your correctness testing, which does benefit from multi-threaded
execution. You should ensure code coverage is disabled in a performance run to avoid artificially slowing your components
down by ensuring the <code class="docutils literal notranslate"><span class="pre">disableCoverage</span></code> group is set on all performance tests (but the command line flag can be used
too just to be safe). So a typical automated performance run would need to modify the usual <code class="docutils literal notranslate"><span class="pre">--ci</span></code> default into something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">performance</span><span class="o">/</span>
<span class="n">pysys</span> <span class="n">run</span> <span class="o">--</span><span class="n">ci</span> <span class="o">--</span><span class="n">threads</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span><span class="n">XcodeCoverage</span><span class="o">=</span><span class="n">false</span>
</pre></div>
</div>
<p>When running performance tests locally to investigate a performance bug, it can be incredibly valuable to run
multiple cycles of each test to generate a more stable baseline, and also to give you a measurable indication of how
variable your results are. There is no point trying to track down a 10% performance regression from a test whose
normal variation is +/-50%! It is also worth customizing the <code class="docutils literal notranslate"><span class="pre">--outdir</span></code> to assign a human-friendly label each time
you do a run against a different build of your application. The <code class="docutils literal notranslate"><span class="pre">outdir</span></code> is recorded with the performance numbers
and also allows you to avoid overwriting previous detailed logging output when doing a new run. So a typical local
execution of a performance test would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pysys</span> <span class="n">run</span> <span class="o">-</span><span class="n">c5</span> <span class="o">--</span><span class="n">outdir</span><span class="o">=</span><span class="k">with</span><span class="o">-</span><span class="n">foobar</span><span class="o">-</span><span class="n">optimization</span> <span class="n">MyTest</span><span class="o">~</span><span class="n">MyMode</span>
</pre></div>
</div>
<p>You may wish to focus on just one mode, or all modes (<code class="docutils literal notranslate"><span class="pre">--modes=ALL</span></code>) or a specific subset of the modes (perhaps
using a regular expression on the command line to indicate which modes are needed). At the end of the test run PySys
will print a summary of the results, including a calculation of the sample standard deviation (if <code class="docutils literal notranslate"><span class="pre">cycles</span></code> &gt; 1)
which you can use to check your test is reliable and to decide whether measured increases/decreases are statistically
significant or just random noise.</p>
</div>
<div class="section" id="comparing-performance-results">
<h4>Comparing performance results<a class="headerlink" href="#comparing-performance-results" title="Permalink to this headline">¶</a></h4>
<p>When using PySys tests to measure your application while you experiment with possible optimizations, consider
listing the <code class="docutils literal notranslate"><span class="pre">.csv</span></code> (or <code class="docutils literal notranslate"><span class="pre">.json</span></code>) summary files containing your baselines (e.g. baseline before any changes, with
optimization A, B, C etc…) in the <code class="docutils literal notranslate"><span class="pre">PYSYS_PERFORMANCE_BASELINES</span></code> environment variable. The
<a class="reference internal" href="../autodocgen/pysys.perf.reporters.html#pysys.perf.reporters.PrintSummaryPerformanceReporter" title="pysys.perf.reporters.PrintSummaryPerformanceReporter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.perf.reporters.PrintSummaryPerformanceReporter</span></code></a> will print a textual comparison from each of the listed
baselines to the current result. You can also run comparisons from the command line at any time by running
the <code class="docutils literal notranslate"><span class="pre">pysys/perf/perfreportstool.py</span></code> script.</p>
<p>When reviewing comparisons, note that some numbers are “better” when large (e.g. rate of sending messages/transactions)
while others are “worse” when large (e.g. latency or response time). The comparison tries to avoid confusion when
looking at such results side by side, by showing “+” results for all improvements and “-” when things got worse.
For each comparison, it prints the %improvement (with a + for bigger-is-better increases and - for reductions, and
vice-versa), and the speedup ratio (newValue/oldValue for bigger-is-better, or oldValue/newValue for smaller is better).
Typically the % is useful for small changes (&lt; 100%) whereas the speedup ratio is more friendly for large changes
(e.g. 3.5x faster). Provided multiple samples are available (from a multi-cycle run), it calculates the standard
deviation (using whichever is the larger of the old and new stdDevs) and expresses the improvement delta as a ratio of
the standard deviation (aka “sigma”) to give a “sigmas” value which indicates statistically how significant the result
is - above <code class="docutils literal notranslate"><span class="pre">+/-</span> <span class="pre">1</span> <span class="pre">sigma</span></code> means there is a 68% chance the change is a real (significant) one, and above
<code class="docutils literal notranslate"><span class="pre">+/-</span> <span class="pre">2</span> <span class="pre">sigmas</span></code> shows a 95% probability of significance.
Results with less than 2 sigmas are not colour-coded since they typically don’t indicate a real change; anything with a
red or green colour is a regression or improvement that is statistically significant and worth paying attention to.</p>
</div>
</div>
<div class="section" id="test-ids-and-structuring-large-projects">
<h3>Test ids and structuring large projects<a class="headerlink" href="#test-ids-and-structuring-large-projects" title="Permalink to this headline">¶</a></h3>
<p>Firstly, try to have everything in a single PySys project if possible. Use subdirectories to structure your tests,
but don’t separate into different PySys projects unless it’s for testing a totally different component with different
testing needs. Keeping everything in the same project gives you the ability to run all your tests
(unit/correctness/perf) from a single command line which could be useful in the future even if you don’t need it right
now.</p>
<p>Each test has a unique <code class="docutils literal notranslate"><span class="pre">id</span></code> which is used in various places such as when
reporting passed/failed outcomes. By default the id is just the name of the
directory containing the <code class="docutils literal notranslate"><span class="pre">pysystest.*</span></code> file.</p>
<p>You can choose a suitable naming convention for your tests. For example,
you might wish to differentiate with just a numeric suffix such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyApp_001</span>
<span class="n">MyApp_002</span>
<span class="n">MyApp_003</span>
</pre></div>
</div>
<p>This has the benefit that it’s easy to refer to tests when communicating with
other developers, and that you can run tests on the command line by specifying
just a number, but you have to look at the test title to discover what it does.</p>
<p>Alternatively you could choose to use a semantically meaningful name for each
test:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MyApp_TimeoutValueWorks</span>
<span class="n">MyApp_TimeoutInvalidValuesAreRejected</span>
<span class="n">MyApp_ValidCredentialsAreAccepted</span>
</pre></div>
</div>
<p>These test ids are easier to understand but can’t be referred to as concisely.</p>
<p>Whatever scheme you use for naming test ids, if you have a large set of tests
you will want to separate them out into different directories, so that
related tests can be executed and maintained together. You might have
different directories for different subsystems/parts of your application,
and/or for different kinds of testing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span>  <span class="p">(</span><span class="n">root</span> <span class="nb">dir</span> <span class="n">containing</span> <span class="n">pysysproject</span><span class="o">.</span><span class="n">xml</span><span class="p">)</span>

<span class="o">/</span><span class="n">SubSystem1</span><span class="o">/</span><span class="n">unit</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem1</span><span class="o">/</span><span class="n">correctness</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem1</span><span class="o">/</span><span class="n">long</span><span class="o">-</span><span class="n">running</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem1</span><span class="o">/</span><span class="n">performance</span><span class="o">/</span>

<span class="o">/</span><span class="n">SubSystem2</span><span class="o">/</span><span class="n">unit</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem2</span><span class="o">/</span><span class="n">correctness</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem2</span><span class="o">/</span><span class="n">long</span><span class="o">-</span><span class="n">running</span><span class="o">/</span>
<span class="o">/</span><span class="n">SubSystem2</span><span class="o">/</span><span class="n">performance</span><span class="o">/</span>
<span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>It is important to ensure every test has a unique id. Although it would be
possible to do this by convention in the individual test directory names,
this is fragile and could lead to clashes if someone forgets. Therefore for
large projects it is usually best to add a <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> file to
provide default configuration for each directory of testcases.</p>
<p>For example, in SubSystem1/performance you could create a <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code>
file containing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;pysysdirconfig&gt;
  &lt;id-prefix&gt;SubSystem1_perf.&lt;/id-prefix&gt;

  &lt;classification&gt;
        &lt;groups inherit=&quot;true&quot;&gt;
          &lt;group&gt;subsystem1&lt;/group&gt;
          &lt;group&gt;performance&lt;/group&gt;
          &lt;group&gt;disableCoverage&lt;/group&gt;
        &lt;/groups&gt;

        &lt;modes inherit=&quot;true&quot;&gt;
        &lt;/modes&gt;

  &lt;/classification&gt;

  &lt;execution-order hint=&quot;-100.0&quot;/&gt;

  &lt;!-- Uncomment this to mark all tests under this directory as skipped
        (overrides the state= attribute on individual tests). --&gt;
  &lt;!-- &lt;skipped reason=&quot;&quot;/&gt; --&gt;

&lt;/pysysdirconfig&gt;
</pre></div>
</div>
<p>This serves several useful purposes:</p>
<ul class="simple">
<li><p>It adds a prefix “SubSystem1_perf.” to the beginning of the test directory
names to ensure there’s a unique id for each one with no chance of conflicts
across different directories.</p></li>
<li><p>It adds groups that make it possible to run all your performance tests, or
all your tests for a particular part of the application, in a single command.</p></li>
<li><p>It disables code coverage instrumentation which could adversely affect your
performance results.</p></li>
<li><p>It specifies that the performance tests will be run with a lower priority,
so they execute after more urgent (and quicker) tests such as unit tests.</p></li>
<li><p>It provides the ability to temporarily skip a set of tests if they are
broken temporarily pending a bug fix.</p></li>
</ul>
<p>By default both modes and groups are inherited from <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> files
in parent directories, but inheriting can be disabled in an individual
descriptor by providing an explicit list of modes, in case you have a few tests that only
make sense in one mode. Alternatively, you could allow the tests to exist
in all modes but call <code class="docutils literal notranslate"><span class="pre">self.skipTest</span> <span class="pre">&lt;BaseTest.skipTest&gt;</span></code> at the start of the test <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.execute" title="pysys.basetest.BaseTest.execute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.execute</span></code></a> method
if the test cannot execute in the current mode.</p>
<p>See the <a class="reference internal" href="TestDescriptors.html#sample-pysysdirconfig-xml"><span class="std std-ref">Sample pysysdirconfig.xml</span></a> for a full example of a directory configuration file.</p>
</div>
<div class="section" id="controlling-execution-order">
<h3>Controlling execution order<a class="headerlink" href="#controlling-execution-order" title="Permalink to this headline">¶</a></h3>
<p>In large projects where the test run takes several hours or days, you may wish
to control the order that PySys executes different groups of tests - or tests
with different modes, to maximize the chance of finding out quickly if
something has gone wrong, and perhaps to prioritize running fast unit and
correctness tests before commencing on longer running performance or soak tests.</p>
<p>By default, PySys runs tests based on the sorting them by the full path of
the <code class="xref py py-obj docutils literal notranslate"><span class="pre">pysystest.*</span></code> files. If you have tests with multiple modes, PySys will
run all tests in their primary modes first, then any/all tests which list a
second mode, followed by 3rd, 4th, etc.</p>
<p>All of this can be customized using the concept of an execution order hint.
Every test descriptor is assigned an execution order hint, which is a positive
or negative floating point number which defaults to 0.0, and is used to sort
the descriptors before execution. Higher execution order hints mean later
execution. If two tests have the same hint, PySys falls back on using the
path of the <code class="docutils literal notranslate"><span class="pre">pysystest.*</span></code> file to determine a canonical order.</p>
<p>The hint for each test is generated by adding together hint components from the
following:</p>
<blockquote>
<div><ul class="simple">
<li><p>A test-specific hint from the <code class="docutils literal notranslate"><span class="pre">pysystest.*</span></code> file’s <code class="docutils literal notranslate"><span class="pre">__pysys_execution_order_hint__</span> <span class="pre">=</span> <span class="pre">``</span> <span class="pre">or</span>
<span class="pre">``&lt;execution-order</span> <span class="pre">hint=&quot;...&quot;/&gt;</span></code>. If the hint is
not specified (the default), the test inherits any hint specified in a
<code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> file in an ancestor folder, or 0.0 if there aren’t
any. Note that hints from <code class="docutils literal notranslate"><span class="pre">pysysdirconfig.xml</span></code> files are not added
together; instead, the most specific wins.</p></li>
<li><p>All <code class="docutils literal notranslate"><span class="pre">&lt;execution-order&gt;</span></code> elements in the project configuration file which
match the mode and/or group of the test. The project configuration
is the place to put mode-specific execution order hints, such as putting
a particular database or web browser mode earlier/later. See the
sample <a class="reference internal" href="ProjectConfiguration.html"><span class="doc">Project Configuration</span></a> file for details.</p></li>
<li><p>For multi-mode tests, the <code class="docutils literal notranslate"><span class="pre">secondaryModesHintDelta</span></code> specified in the project
configuration (unless it’s set to zero), multiplied by a number indicating
which mode this is. If a test had 3 modes Mode1, Mode2 and Mode3 then
the primary mode(s) (Mode1) would get no additional hint, Mode2 would get
<code class="docutils literal notranslate"><span class="pre">secondaryModesHintDelta</span></code> added to its hint and Mode3 would get
<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">secondaryModesHintDelta</span></code> added to its hint. This is the mechanism
PySys uses to ensure all tests run first in their primary modes before
any tests run in their secondary modes. Usually the default value of
<code class="docutils literal notranslate"><span class="pre">secondaryModesHintDelta</span> <span class="pre">=</span> <span class="pre">+100.0</span></code> is useful and avoids the need for too
much mode-specific hint configuration (see above). However if you prefer to
turn it off to have more manual control - or you prefer each test to run
in all modes before moving on to the next test - then simply set
<code class="docutils literal notranslate"><span class="pre">secondaryModesHintDelta</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
</ul>
</div></blockquote>
<p>For really advanced cases, you can programmatically set the
<code class="docutils literal notranslate"><span class="pre">executionOrderHint</span></code> on each descriptor by providing a custom
<a class="reference internal" href="../autodocgen/pysys.config.descriptor.html#pysys.config.descriptor.DescriptorLoader" title="pysys.config.descriptor.DescriptorLoader"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.config.descriptor.DescriptorLoader</span></code></a> or in the constructor of a
custom <a class="reference internal" href="../autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner" title="pysys.baserunner.BaseRunner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.baserunner.BaseRunner</span></code></a> class or plugin.</p>
</div>
<div class="section" id="runner-and-writer-plugins">
<h3>Runner and writer plugins<a class="headerlink" href="#runner-and-writer-plugins" title="Permalink to this headline">¶</a></h3>
<p>Plugins can be used to extend PySys with additional capabilities:</p>
<ul>
<li><p><strong>runner plugins</strong>; these are instantiated just once per invocation of PySys, by the BaseRunner,
before <a class="reference internal" href="../autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner.setup" title="pysys.baserunner.BaseRunner.setup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.baserunner.BaseRunner.setup()</span></code></a> is called. Unlike test plugins, any processes or state they maintain are
shared across all tests. These can be used to start servers/VMs that are shared across tests.
Runner plugins are configured with <code class="docutils literal notranslate"><span class="pre">&lt;runner-plugin</span> <span class="pre">classname=&quot;...&quot;</span> <span class="pre">alias=&quot;...&quot;/&gt;</span></code> and can be any Python
class provided it has a method <code class="docutils literal notranslate"><span class="pre">setup(self,</span> <span class="pre">runner)</span></code> (and no constructor arguments).</p>
<p>Runner plugins that generate output files/directories should by default put that output under either the
<a class="reference internal" href="../autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner" title="pysys.baserunner.BaseRunner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runner.output</span></code></a> directory, or (for increased prominence) the <code class="docutils literal notranslate"><span class="pre">runner.output+'/..'</span></code>
directory (which is typically <code class="docutils literal notranslate"><span class="pre">testRootDir</span></code> unless an absolute <code class="docutils literal notranslate"><span class="pre">--outdir</span></code> path was provided).</p>
</li>
<li><p><strong>writer plugins</strong>: this kind of plugin has existed in PySys for many releases and are effectively a special kind of
runner plugin with extra callbacks to allow them to write test results and/or output files to a variety of
destinations. Writers must implement a similar but different interface to other runner plugins; see <a class="reference internal" href="../autodocgen/pysys.writer.html#module-pysys.writer" title="pysys.writer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer</span></code></a>
for details. They can be used for everything from writing test outcome to an XML file, to archiving output files, to
collecting files from each test output and using them to generate a code coverage report during cleanup at the end
of the run.</p></li>
</ul>
<p>To make your plugin configurable, add a static field for each plugin property, which defines the default value
and (implicitly) the type. After construction of each plugin, an attribute is assigned with the actual value
of each plugin property so each property can be accessed using <code class="docutils literal notranslate"><span class="pre">self.propname</span></code> (by the time the plugin’s setup method
is called). In addition to plugin properties, <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span> <span class="pre">-Xkey=value</span></code> command line options for the plugin
(if needed) can be accessed using the runner’s <a class="reference internal" href="../autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner.getXArg" title="pysys.baserunner.BaseRunner.getXArg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.baserunner.BaseRunner.getXArg()</span></code></a> method.</p>
<p>For an example of a runner plugin, see the cookbook sample. The configuration looks like this:</p>
<p>With configuration like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">pysysproject</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">test</span><span class="o">-</span><span class="n">plugin</span> <span class="n">classname</span><span class="o">=</span><span class="s2">&quot;myorg.testplugin.MyTestPlugin&quot;</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&quot;myalias&quot;</span><span class="o">&gt;</span>
                    <span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myPluginProperty&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;my value&quot;</span><span class="o">/&gt;</span>
        <span class="o">&lt;/</span><span class="n">test</span><span class="o">-</span><span class="n">plugin</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">pysysproject</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>When creating a runner plugin you may need somewhere to put output files, logs etc. Plugins that generate output
files/directories should by default put that output in a dedicated directory either the
<a class="reference internal" href="../autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner" title="pysys.baserunner.BaseRunner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runner.output</span></code></a> directory, or (for increased prominence if it’s something users will
look at a lot) a directory one level up e.g. <code class="docutils literal notranslate"><span class="pre">runner.output+'/../myplugin'</span></code> (which is typically under <code class="docutils literal notranslate"><span class="pre">testRootDir</span></code>
unless an absolute <code class="docutils literal notranslate"><span class="pre">--outdir</span></code> path was provided) .
A prefix of double underscore <code class="docutils literal notranslate"><span class="pre">__pysys</span></code> is recommended under testRootDir to distinguish dynamically created
directories (ignored by version control) from the testcase directories (checked into version control).</p>
<p>For examples of the project configuration, including how to set plugin-specific properties that will be passed to
its constructor, see <a class="reference internal" href="ProjectConfiguration.html"><span class="doc">Project Configuration</span></a>.</p>
<p>(Occasionally some user may wish to add their own custom writer that is not defined in the main <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code> file,
and this can be achieved by putting the additional configuration into a user-specific XML file and setting its path in
the environment variable <code class="docutils literal notranslate"><span class="pre">PYSYS_PROJECT_APPEND</span></code>).</p>
</div>
<div class="section" id="configuring-and-overriding-test-options">
<h3>Configuring and overriding test options<a class="headerlink" href="#configuring-and-overriding-test-options" title="Permalink to this headline">¶</a></h3>
<p>PySys provides two mechanisms for specifying options such as credentials,
hostnames, or test duration/iteration that you might want to change or
override when running tests:</p>
<ul>
<li><p><em>Testcase attributes</em>, which are just variables on the Python testcase
instance (or a <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> subclass shared by many tests).
Attributes can be overridden on the command line using <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span> <span class="pre">-Xattr=value</span></code>.</p>
<p>Attributes are useful for settings specific to an individual testcase such as
the number of iterations or time duration to use for a performance test.
A user running the test locally you might want to temporarily set to a lower
iteration count while getting the test right, or perhaps try
a higher value to get a more stable performance result.</p>
</li>
<li><p><em>Project properties</em>. The default value is specified in the <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code>
file or in a <code class="docutils literal notranslate"><span class="pre">.properties</span></code> file referenced from it.</p>
<p>Properties can be overridden using an environment variable.
Project properties are useful for things like credentials and hostnames that
are shared across many testcases, and where you might want to set up
customizations in your shell so that you don’t need to keep specifying them
every time you invoke <code class="docutils literal notranslate"><span class="pre">pysys</span> <span class="pre">run</span></code>.</p>
</li>
</ul>
<p>To use a testcase attribute, set the default value on your test or basetest as a static attribute on the test
class, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PySysTest</span><span class="p">(</span><span class="n">BaseTest</span><span class="p">):</span>

        <span class="n">myIterationCount</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="mi">1000</span> <span class="c1"># can be overridden with -XmyIterationCount=</span>

        <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using iterations=</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">myIterationCount</span><span class="p">)</span>
                <span class="o">...</span>
</pre></div>
</div>
<p>Once the default value is defined with a static attribute, you can override the value
when you run your test using the <code class="docutils literal notranslate"><span class="pre">-X</span></code> option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pysys</span> <span class="n">run</span> <span class="o">-</span><span class="n">XmyIterationCount</span><span class="o">=</span><span class="mi">10</span>
</pre></div>
</div>
<p>If the attribute was defined with a default value of int, float, bool or list then
the <code class="docutils literal notranslate"><span class="pre">-X</span></code> value will be automatically converted to that type; otherwise, it will
be a string.</p>
<p>If instead of setting a default for just one test you wish to set the default
for many tests from your custom <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> subclass, then you would do the same thing in the
definition of that <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest" title="pysys.basetest.BaseTest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest</span></code></a> subclass. If you don’t have a custom BaseTest class, you can use
<a class="reference internal" href="../autodocgen/pysys.baserunner.html#pysys.baserunner.BaseRunner.getXArg" title="pysys.baserunner.BaseRunner.getXArg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">self.runner.getXArg()</span></code></a> from any plugin to get the value or default, with the same
type conversion described above.</p>
<p>The other mechanism that PySys supports for configurable test options is
project properties.</p>
<p>To use a project property that can be overridden with an environment variable,
add a <code class="docutils literal notranslate"><span class="pre">property</span></code> element to your <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code> file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myCredentials&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{env.MYORG_CREDENTIALS}</span><span class="s2">&quot;</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;testuser:testpassword&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>This property can will take the value of the specified environment variable,
or else the default if any undefined properties/env vars are included in value. Note that if the value contains
unresolved variables and there is no valid default, the project will fail to load.</p>
<p>You may want to set the attribute <code class="docutils literal notranslate"><span class="pre">pathMustExist=&quot;true&quot;</span></code> when defining properties that refer to a path such as a
build output directory that should always be present.</p>
<p>Another way to specify default project property values is to put them into a <code class="docutils literal notranslate"><span class="pre">.properties</span></code> file. You can use
properties to specify which file is loaded, so it would be possible to customize using environment variables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myProjectPropertiesFile&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{env.MYORG_CUSTOM_PROJECT_PROPERTIES}</span><span class="s2">&quot;</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{testRootDir}</span><span class="s2">/default-config.properties&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nb">property</span> <span class="n">file</span><span class="o">=</span><span class="s2">&quot;$</span><span class="si">{myProjectPropertiesFile}</span><span class="s2">&quot;</span> <span class="n">pathMustExist</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>To use projects properties in your testcase, just access the attributes on
<a class="reference internal" href="../autodocgen/pysys.config.project.html#pysys.config.project.Project" title="pysys.config.project.Project"><code class="xref py py-obj docutils literal notranslate"><span class="pre">self.project</span></code></a> from either a test instance or a runner:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">username</span><span class="p">,</span> <span class="n">password</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">myCredentials</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using username=</span><span class="si">%s</span><span class="s1"> and password=</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span>
</pre></div>
</div>
<p>Project properties are always be of string type, but <a class="reference internal" href="../autodocgen/pysys.config.project.html#pysys.config.project.Project.getProperty" title="pysys.config.project.Project.getProperty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.config.project.Project.getProperty()</span></code></a> can be used to
convert the value to other types when needed.</p>
</div>
<div class="section" id="thread-safety">
<h3>Thread-safety<a class="headerlink" href="#thread-safety" title="Permalink to this headline">¶</a></h3>
<p>As your test suite grows, the ability to run tests in parallel will be increasingly important, so make sure your
tests and any shared plugin code do not manipulate shared data structures or files in a way that could cause
race conditions.</p>
<p>Most Python library functions are safe to use, but you should avoid calling <code class="docutils literal notranslate"><span class="pre">locale.getpreferredencoding()</span></code>
(use <a class="reference internal" href="../autodocgen/pysys.constants.html#pysys.constants.PREFERRED_ENCODING" title="pysys.constants.PREFERRED_ENCODING"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.constants.PREFERRED_ENCODING</span></code></a> instead) and <code class="docutils literal notranslate"><span class="pre">shutil.make_archive</span></code> which are not.</p>
<p>It is also important not to change to the working directory of the PySys process or its environment (<code class="docutils literal notranslate"><span class="pre">os.environ</span></code>)
while tests are executing. Any setup that might involve changing the environment - including initialization of
some libraries (e.g. Matplotlib) must be performed before tests start in the <code class="docutils literal notranslate"><span class="pre">setup</span></code> of a runner plugin (or runner),
so that everything is stable ready for tests to be executed.</p>
<p>To avoid dangerous and hard-to-debug race conditions, PySys has built-in checking for changes to the working directory
and os.environ and the test run will fail if either is detected.</p>
</div>
<div class="section" id="producing-code-coverage-reports">
<h3>Producing code coverage reports<a class="headerlink" href="#producing-code-coverage-reports" title="Permalink to this headline">¶</a></h3>
<p>PySys can be extended to produce code coverage reports for any language, by creating a writer plugin.</p>
<p>There is an existing writer that produces coverage reports for programs written in Python called
<a class="reference internal" href="../autodocgen/pysys.writer.coverage.html#pysys.writer.coverage.PythonCoverageWriter" title="pysys.writer.coverage.PythonCoverageWriter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.coverage.PythonCoverageWriter</span></code></a>, which uses the <code class="docutils literal notranslate"><span class="pre">coverage.py</span></code> library. To use this you need to add the
<code class="docutils literal notranslate"><span class="pre">&lt;writer&gt;</span></code> to your project (see the sample <a class="reference internal" href="ProjectConfiguration.html"><span class="doc">Project Configuration</span></a> for an example) and make sure you’re starting
your Python processes with coverage support enabled, by using <a class="reference internal" href="BaseTest.html#pysys.basetest.BaseTest.startPython" title="pysys.basetest.BaseTest.startPython"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BaseTest.startPython</span></code></a>.</p>
<p>The usual way to enable code coverage (for all supported languages) is to set <code class="docutils literal notranslate"><span class="pre">-XcodeCoverage</span></code> when running your
tests (or to run with <code class="docutils literal notranslate"><span class="pre">--ci</span></code> which does this automatically). Individual writers may additionally provide their own
properties to allow fine-grained control e.g. <code class="docutils literal notranslate"><span class="pre">-XpythonCoverage=true/false</span></code>.</p>
<p>Be sure to add the <code class="docutils literal notranslate"><span class="pre">disableCoverage</span></code> group to any tests (or test directories) that should not use coverage,
such as performance tests.</p>
<p>If you wish to produce coverage reports using any other language, this is easy to achieve by following the same pattern:</p>
<ul>
<li><p>When your tests start the program(s) whose coverage is to be measured, add the required arguments or environment
variables to enable coverage using the coverage tool of your choice. The most convenient place to put helper methods
for starting your application is in a custom test plugin class.</p>
<p>When starting your process, you can detect whether to enable code coverage like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">getBoolProperty</span><span class="p">(</span><span class="s1">&#39;mylanguageCoverage&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">runner</span><span class="o">.</span><span class="n">getBoolProperty</span><span class="p">(</span><span class="s1">&#39;codeCoverage&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">disableCoverage</span><span class="p">:</span>
      <span class="o">...</span>
</pre></div>
</div>
<p>Often you will need to set an environment variable to indicate the filename that coverage should be generated under.
Make sure to use a unique filename so that multiple processes started by the same test do not clash. Often you
will need to ensure that your application is shutdown cleanly (rather than being automatically killed at the end of
the test) so that it has a chance to write the code coverage information.</p>
</li>
<li><p>Create a custom writer class which collects coverage files (matching a specific regex pattern) from the output
directory. The usual way to do this would be to subclass <a class="reference internal" href="../autodocgen/pysys.writer.testoutput.html#pysys.writer.testoutput.CollectTestOutputWriter" title="pysys.writer.testoutput.CollectTestOutputWriter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.testoutput.CollectTestOutputWriter</span></code></a>. Configure
default values for main configuration properties (by defining them as static variables in your class). Then implement
<a class="reference internal" href="../autodocgen/pysys.writer.api.html#pysys.writer.api.BaseResultsWriter.isEnabled" title="pysys.writer.api.BaseResultsWriter.isEnabled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.api.BaseResultsWriter.isEnabled()</span></code></a> to define when coverage reporting will happen, and run the
required processes to combine coverage files and generate a report in the destDir in
<a class="reference internal" href="../autodocgen/pysys.writer.api.html#pysys.writer.api.BaseResultsWriter.cleanup" title="pysys.writer.api.BaseResultsWriter.cleanup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.api.BaseResultsWriter.cleanup()</span></code></a>, which will execute after all tests have completed.</p>
<p>Finally, add the new writer class to your <code class="docutils literal notranslate"><span class="pre">pysysproject.xml</span></code> file.</p>
</li>
<li><p>Add the <code class="docutils literal notranslate"><span class="pre">disableCoverage</span></code> group to any tests (or test directories) that should not use coverage,
such as performance tests.</p></li>
<li><p>If using a continuous integration system or centralized code coverage database, you could optionally upload the
coverage data there from the directory PySys collected it into, so there is a permanent record of
any changes in coverage over time. The artifact publishing capability of
<a class="reference internal" href="../autodocgen/pysys.writer.testoutput.html#pysys.writer.testoutput.CollectTestOutputWriter" title="pysys.writer.testoutput.CollectTestOutputWriter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pysys.writer.testoutput.CollectTestOutputWriter</span></code></a> will help with that.</p></li>
<li><p>If you want to compare code coverage between branches/commits you will need to ensure the same set of tests is
running for both comparison points. So if you have a full test run and a smaller set of unit or smoke tests that
execute in pull requests it may be useful to generate two reports - one which includes all tests (for manual
reviewing) and another that includes just the tests executed in the unit tests or in pull requests, for automated
comparisons and quality gates.
This can be achieved by adding an additional coverage writer that will ignore the generated coverage files
from the non-unit/smoke tests:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;includeTestIf&quot;</span><span class="o">&gt;</span><span class="k">lambda</span> <span class="n">testObj</span><span class="p">:</span>
        <span class="s1">&#39;unitTest&#39;</span> <span class="ow">in</span> <span class="n">testObj</span><span class="o">.</span><span class="n">descriptor</span><span class="o">.</span><span class="n">groups</span>
        <span class="ow">or</span> <span class="n">testObj</span><span class="o">.</span><span class="n">project</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span><span class="s1">&#39;isLocalDeveloperTestRun&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="nb">property</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ProjectConfiguration.html" class="btn btn-neutral float-right" title="Project Configuration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="BaseTest.html" class="btn btn-neutral float-left" title="The BaseTest Class" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2006-2023 M.B. Grieve; documentation last updated on 2023-10-19

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>